// Generated by rstantools.  Do not edit by hand.

#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.32.2
#include <stan/model/model_header.hpp>
namespace model_igbm_namespace {
using stan::model::model_base_crtp;
using namespace stan::math;
stan::math::profile_map profiles__;
static constexpr std::array<const char*, 365> locations_array__ =
  {" (found before start of program)",
  " (in 'string', line 252, column 0 to column 8)",
  " (in 'string', line 253, column 0 to column 21)",
  " (in 'string', line 254, column 0 to column 38)",
  " (in 'string', line 255, column 0 to column 30)",
  " (in 'string', line 256, column 0 to column 38)",
  " (in 'string', line 257, column 0 to column 21)",
  " (in 'string', line 258, column 0 to column 27)",
  " (in 'string', line 261, column 0 to column 34)",
  " (in 'string', line 262, column 0 to column 22)",
  " (in 'string', line 263, column 0 to column 44)",
  " (in 'string', line 264, column 0 to column 38)",
  " (in 'string', line 265, column 0 to column 36)",
  " (in 'string', line 266, column 0 to column 47)",
  " (in 'string', line 267, column 0 to column 24)",
  " (in 'string', line 268, column 0 to column 41)",
  " (in 'string', line 269, column 0 to column 42)",
  " (in 'string', line 270, column 0 to column 20)",
  " (in 'string', line 271, column 0 to column 23)",
  " (in 'string', line 273, column 0 to column 63)",
  " (in 'string', line 274, column 0 to column 66)",
  " (in 'string', line 275, column 0 to column 76)",
  " (in 'string', line 345, column 0 to column 22)",
  " (in 'string', line 346, column 0 to column 23)",
  " (in 'string', line 347, column 0 to column 30)",
  " (in 'string', line 349, column 0 to column 29)",
  " (in 'string', line 350, column 0 to column 22)",
  " (in 'string', line 351, column 0 to column 14)",
  " (in 'string', line 276, column 34 to column 129)",
  " (in 'string', line 276, column 16 to column 129)",
  " (in 'string', line 276, column 0 to column 129)",
  " (in 'string', line 277, column 0 to column 26)",
  " (in 'string', line 278, column 0 to column 48)",
  " (in 'string', line 280, column 0 to column 41)",
  " (in 'string', line 281, column 38 to column 117)",
  " (in 'string', line 281, column 23 to column 117)",
  " (in 'string', line 281, column 0 to column 117)",
  " (in 'string', line 282, column 0 to column 16)",
  " (in 'string', line 286, column 1 to line 288, column 33)",
  " (in 'string', line 285, column 7 to line 289, column 1)",
  " (in 'string', line 284, column 2 to column 38)",
  " (in 'string', line 283, column 22 to line 285, column 1)",
  " (in 'string', line 283, column 0 to line 289, column 1)",
  " (in 'string', line 290, column 0 to column 44)",
  " (in 'string', line 292, column 0 to column 68)",
  " (in 'string', line 293, column 0 to column 45)",
  " (in 'string', line 294, column 0 to column 45)",
  " (in 'string', line 295, column 0 to column 46)",
  " (in 'string', line 296, column 0 to column 42)",
  " (in 'string', line 297, column 0 to column 43)",
  " (in 'string', line 299, column 0 to line 305, column 36)",
  " (in 'string', line 308, column 12 to column 51)",
  " (in 'string', line 308, column 1 to column 51)",
  " (in 'string', line 311, column 2 to column 63)",
  " (in 'string', line 313, column 2 to column 103)",
  " (in 'string', line 315, column 13 to column 120)",
  " (in 'string', line 315, column 2 to column 120)",
  " (in 'string', line 309, column 15 to line 316, column 2)",
  " (in 'string', line 309, column 1 to line 316, column 2)",
  " (in 'string', line 307, column 19 to line 317, column 1)",
  " (in 'string', line 307, column 0 to line 317, column 1)",
  " (in 'string', line 353, column 0 to column 39)",
  " (in 'string', line 355, column 0 to column 41)",
  " (in 'string', line 359, column 2 to column 81)",
  " (in 'string', line 361, column 42 to column 141)",
  " (in 'string', line 361, column 7 to column 141)",
  " (in 'string', line 360, column 42 to column 122)",
  " (in 'string', line 360, column 2 to line 361, column 141)",
  " (in 'string', line 358, column 16 to line 362, column 2)",
  " (in 'string', line 358, column 1 to line 362, column 2)",
  " (in 'string', line 363, column 1 to column 36)",
  " (in 'string', line 357, column 19 to line 364, column 1)",
  " (in 'string', line 357, column 0 to line 364, column 1)",
  " (in 'string', line 366, column 0 to column 31)",
  " (in 'string', line 321, column 0 to column 60)",
  " (in 'string', line 322, column 0 to column 41)",
  " (in 'string', line 323, column 0 to column 41)",
  " (in 'string', line 324, column 0 to column 28)",
  " (in 'string', line 325, column 0 to column 28)",
  " (in 'string', line 330, column 40 to column 90)",
  " (in 'string', line 330, column 5 to column 90)",
  " (in 'string', line 329, column 40 to column 108)",
  " (in 'string', line 329, column 5 to line 330, column 90)",
  " (in 'string', line 328, column 40 to column 133)",
  " (in 'string', line 328, column 5 to line 330, column 90)",
  " (in 'string', line 327, column 40 to column 109)",
  " (in 'string', line 327, column 5 to line 330, column 90)",
  " (in 'string', line 326, column 40 to column 109)",
  " (in 'string', line 326, column 0 to line 330, column 90)",
  " (in 'string', line 335, column 40 to column 85)",
  " (in 'string', line 335, column 5 to column 85)",
  " (in 'string', line 334, column 40 to column 106)",
  " (in 'string', line 334, column 5 to line 335, column 85)",
  " (in 'string', line 333, column 40 to column 134)",
  " (in 'string', line 333, column 5 to line 335, column 85)",
  " (in 'string', line 332, column 40 to column 107)",
  " (in 'string', line 332, column 5 to line 335, column 85)",
  " (in 'string', line 331, column 40 to column 107)",
  " (in 'string', line 331, column 0 to line 335, column 85)",
  " (in 'string', line 340, column 43 to column 133)",
  " (in 'string', line 340, column 8 to column 133)",
  " (in 'string', line 339, column 43 to column 114)",
  " (in 'string', line 339, column 3 to line 340, column 133)",
  " (in 'string', line 338, column 17 to line 341, column 3)",
  " (in 'string', line 338, column 2 to line 341, column 3)",
  " (in 'string', line 337, column 19 to line 342, column 2)",
  " (in 'string', line 337, column 1 to line 342, column 2)",
  " (in 'string', line 170, column 0 to column 6)",
  " (in 'string', line 171, column 0 to column 10)",
  " (in 'string', line 172, column 7 to column 12)",
  " (in 'string', line 172, column 13 to column 14)",
  " (in 'string', line 172, column 0 to column 26)",
  " (in 'string', line 173, column 0 to column 21)",
  " (in 'string', line 174, column 0 to column 38)",
  " (in 'string', line 175, column 0 to column 14)",
  " (in 'string', line 176, column 0 to column 16)",
  " (in 'string', line 177, column 0 to column 17)",
  " (in 'string', line 178, column 6 to column 7)",
  " (in 'string', line 178, column 0 to column 23)",
  " (in 'string', line 179, column 7 to column 8)",
  " (in 'string', line 179, column 0 to column 19)",
  " (in 'string', line 180, column 0 to column 23)",
  " (in 'string', line 181, column 6 to column 7)",
  " (in 'string', line 181, column 16 to column 17)",
  " (in 'string', line 181, column 0 to column 24)",
  " (in 'string', line 182, column 6 to column 11)",
  " (in 'string', line 182, column 12 to column 13)",
  " (in 'string', line 182, column 0 to column 59)",
  " (in 'string', line 183, column 0 to column 8)",
  " (in 'string', line 184, column 6 to column 11)",
  " (in 'string', line 184, column 0 to column 21)",
  " (in 'string', line 185, column 6 to column 11)",
  " (in 'string', line 185, column 0 to column 34)",
  " (in 'string', line 186, column 6 to column 11)",
  " (in 'string', line 186, column 0 to column 35)",
  " (in 'string', line 187, column 18 to column 23)",
  " (in 'string', line 187, column 0 to column 29)",
  " (in 'string', line 188, column 11 to column 12)",
  " (in 'string', line 188, column 0 to column 33)",
  " (in 'string', line 190, column 0 to column 23)",
  " (in 'string', line 191, column 0 to column 23)",
  " (in 'string', line 197, column 0 to column 51)",
  " (in 'string', line 206, column 0 to column 48)",
  " (in 'string', line 207, column 0 to column 36)",
  " (in 'string', line 208, column 0 to column 37)",
  " (in 'string', line 209, column 0 to column 34)",
  " (in 'string', line 210, column 0 to column 37)",
  " (in 'string', line 211, column 0 to column 36)",
  " (in 'string', line 220, column 0 to column 51)",
  " (in 'string', line 221, column 0 to column 39)",
  " (in 'string', line 222, column 0 to column 40)",
  " (in 'string', line 223, column 0 to column 37)",
  " (in 'string', line 224, column 0 to column 40)",
  " (in 'string', line 225, column 0 to column 39)",
  " (in 'string', line 226, column 0 to column 29)",
  " (in 'string', line 227, column 0 to column 29)",
  " (in 'string', line 228, column 0 to column 40)",
  " (in 'string', line 229, column 0 to column 37)",
  " (in 'string', line 232, column 18 to column 23)",
  " (in 'string', line 232, column 0 to column 33)",
  " (in 'string', line 233, column 0 to column 17)",
  " (in 'string', line 234, column 6 to column 19)",
  " (in 'string', line 234, column 0 to column 30)",
  " (in 'string', line 235, column 0 to column 22)",
  " (in 'string', line 236, column 0 to column 20)",
  " (in 'string', line 237, column 6 to column 17)",
  " (in 'string', line 237, column 0 to column 59)",
  " (in 'string', line 238, column 7 to column 8)",
  " (in 'string', line 238, column 0 to column 45)",
  " (in 'string', line 239, column 7 to column 19)",
  " (in 'string', line 239, column 0 to column 60)",
  " (in 'string', line 241, column 20 to column 52)",
  " (in 'string', line 241, column 0 to column 52)",
  " (in 'string', line 242, column 0 to column 11)",
  " (in 'string', line 243, column 0 to column 15)",
  " (in 'string', line 244, column 0 to column 17)",
  " (in 'string', line 245, column 0 to column 46)",
  " (in 'string', line 246, column 0 to column 47)",
  " (in 'string', line 247, column 0 to column 48)",
  " (in 'string', line 248, column 0 to column 33)",
  " (in 'string', line 249, column 0 to column 33)",
  " (in 'string', line 253, column 6 to column 7)",
  " (in 'string', line 254, column 6 to column 23)",
  " (in 'string', line 256, column 6 to column 7)",
  " (in 'string', line 258, column 7 to column 19)",
  " (in 'string', line 261, column 7 to column 16)",
  " (in 'string', line 261, column 18 to column 19)",
  " (in 'string', line 263, column 18 to column 23)",
  " (in 'string', line 263, column 25 to column 26)",
  " (in 'string', line 264, column 6 to column 13)",
  " (in 'string', line 265, column 6 to column 23)",
  " (in 'string', line 266, column 6 to column 11)",
  " (in 'string', line 266, column 13 to column 24)",
  " (in 'string', line 267, column 7 to column 12)",
  " (in 'string', line 267, column 14 to column 15)",
  " (in 'string', line 268, column 18 to column 23)",
  " (in 'string', line 268, column 25 to column 26)",
  " (in 'string', line 269, column 18 to column 23)",
  " (in 'string', line 269, column 25 to column 26)",
  " (in 'string', line 270, column 7 to column 8)",
  " (in 'string', line 270, column 10 to column 11)",
  " (in 'string', line 271, column 7 to column 8)",
  " (in 'string', line 271, column 10 to column 11)",
  " (in 'string', line 273, column 7 to column 8)",
  " (in 'string', line 273, column 10 to column 11)",
  " (in 'string', line 274, column 7 to column 8)",
  " (in 'string', line 274, column 10 to column 11)",
  " (in 'string', line 275, column 7 to column 20)",
  " (in 'string', line 275, column 22 to column 23)",
  " (in 'string', line 345, column 7 to column 12)",
  " (in 'string', line 346, column 7 to column 12)",
  " (in 'string', line 347, column 7 to column 12)",
  " (in 'string', line 347, column 14 to column 15)",
  " (in 'string', line 349, column 7 to column 12)",
  " (in 'string', line 349, column 13 to column 14)",
  " (in 'string', line 350, column 7 to column 12)",
  " (in 'string', line 4, column 8 to column 9)",
  " (in 'string', line 4, column 11 to column 12)",
  " (in 'string', line 4, column 1 to column 40)",
  " (in 'string', line 5, column 1 to column 13)",
  " (in 'string', line 8, column 4 to column 25)",
  " (in 'string', line 9, column 4 to column 13)",
  " (in 'string', line 7, column 21 to line 10, column 3)",
  " (in 'string', line 7, column 2 to line 10, column 3)",
  " (in 'string', line 6, column 18 to line 11, column 2)",
  " (in 'string', line 6, column 1 to line 11, column 2)",
  " (in 'string', line 12, column 1 to column 10)",
  " (in 'string', line 3, column 38 to line 13, column 1)",
  " (in 'string', line 15, column 2 to column 22)",
  " (in 'string', line 16, column 2 to column 22)",
  " (in 'string', line 17, column 9 to column 14)",
  " (in 'string', line 17, column 16 to column 17)",
  " (in 'string', line 17, column 2 to column 26)",
  " (in 'string', line 18, column 2 to column 14)",
  " (in 'string', line 21, column 6 to column 46)",
  " (in 'string', line 22, column 6 to column 15)",
  " (in 'string', line 20, column 18 to line 23, column 4)",
  " (in 'string', line 20, column 3 to line 23, column 4)",
  " (in 'string', line 19, column 16 to line 24, column 2)",
  " (in 'string', line 19, column 1 to line 24, column 2)",
  " (in 'string', line 25, column 2 to column 16)",
  " (in 'string', line 14, column 42 to line 26, column 1)",
  " (in 'string', line 28, column 2 to column 30)",
  " (in 'string', line 29, column 9 to column 10)",
  " (in 'string', line 29, column 12 to column 13)",
  " (in 'string', line 29, column 2 to column 22)",
  " (in 'string', line 30, column 2 to column 14)",
  " (in 'string', line 32, column 4 to column 25)",
  " (in 'string', line 33, column 4 to column 13)",
  " (in 'string', line 31, column 17 to line 34, column 3)",
  " (in 'string', line 31, column 2 to line 34, column 3)",
  " (in 'string', line 35, column 2 to column 16)",
  " (in 'string', line 27, column 52 to line 36, column 1)",
  " (in 'string', line 38, column 1 to column 17)",
  " (in 'string', line 39, column 7 to column 14)",
  " (in 'string', line 39, column 1 to column 23)",
  " (in 'string', line 40, column 1 to column 13)",
  " (in 'string', line 43, column 2 to column 16)",
  " (in 'string', line 44, column 2 to column 11)",
  " (in 'string', line 42, column 18 to line 45, column 4)",
  " (in 'string', line 42, column 3 to line 45, column 4)",
  " (in 'string', line 41, column 16 to line 46, column 2)",
  " (in 'string', line 41, column 1 to line 46, column 2)",
  " (in 'string', line 47, column 1 to column 10)",
  " (in 'string', line 37, column 45 to line 48, column 1)",
  " (in 'string', line 50, column 8 to column 23)",
  " (in 'string', line 50, column 2 to column 34)",
  " (in 'string', line 51, column 2 to column 8)",
  " (in 'string', line 52, column 2 to column 8)",
  " (in 'string', line 53, column 2 to column 14)",
  " (in 'string', line 54, column 2 to column 14)",
  " (in 'string', line 55, column 32 to column 63)",
  " (in 'string', line 55, column 17 to column 63)",
  " (in 'string', line 55, column 2 to column 63)",
  " (in 'string', line 56, column 2 to column 13)",
  " (in 'string', line 49, column 41 to line 57, column 1)",
  " (in 'string', line 59, column 8 to column 23)",
  " (in 'string', line 59, column 2 to column 34)",
  " (in 'string', line 60, column 2 to column 8)",
  " (in 'string', line 61, column 2 to column 8)",
  " (in 'string', line 62, column 2 to column 14)",
  " (in 'string', line 63, column 2 to column 14)",
  " (in 'string', line 64, column 32 to column 63)",
  " (in 'string', line 64, column 17 to column 63)",
  " (in 'string', line 64, column 2 to column 63)",
  " (in 'string', line 65, column 2 to column 13)",
  " (in 'string', line 58, column 41 to line 66, column 1)",
  " (in 'string', line 74, column 2 to column 23)",
  " (in 'string', line 75, column 2 to column 23)",
  " (in 'string', line 76, column 2 to column 23)",
  " (in 'string', line 77, column 8 to column 19)",
  " (in 'string', line 77, column 2 to column 32)",
  " (in 'string', line 78, column 8 to column 9)",
  " (in 'string', line 78, column 2 to column 22)",
  " (in 'string', line 79, column 8 to column 13)",
  " (in 'string', line 79, column 2 to column 25)",
  " (in 'string', line 80, column 8 to column 9)",
  " (in 'string', line 80, column 2 to column 67)",
  " (in 'string', line 82, column 8 to column 13)",
  " (in 'string', line 82, column 2 to column 47)",
  " (in 'string', line 84, column 2 to column 41)",
  " (in 'string', line 85, column 2 to column 41)",
  " (in 'string', line 86, column 2 to column 41)",
  " (in 'string', line 87, column 8 to column 9)",
  " (in 'string', line 87, column 2 to column 63)",
  " (in 'string', line 90, column 1 to column 36)",
  " (in 'string', line 91, column 1 to column 32)",
  " (in 'string', line 93, column 1 to line 95, column 81)",
  " (in 'string', line 97, column 1 to column 44)",
  " (in 'string', line 99, column 1 to column 83)",
  " (in 'string', line 101, column 1 to column 73)",
  " (in 'string', line 103, column 1 to column 62)",
  " (in 'string', line 105, column 1 to column 68)",
  " (in 'string', line 107, column 1 to column 49)",
  " (in 'string', line 89, column 16 to line 108, column 4)",
  " (in 'string', line 89, column 2 to line 108, column 4)",
  " (in 'string', line 109, column 2 to column 15)",
  " (in 'string', line 73, column 7 to line 110, column 1)",
  " (in 'string', line 120, column 2 to column 9)",
  " (in 'string', line 121, column 9 to column 24)",
  " (in 'string', line 121, column 2 to column 45)",
  " (in 'string', line 122, column 9 to column 24)",
  " (in 'string', line 122, column 2 to column 34)",
  " (in 'string', line 123, column 9 to column 24)",
  " (in 'string', line 123, column 2 to column 28)",
  " (in 'string', line 124, column 8 to column 19)",
  " (in 'string', line 124, column 20 to column 35)",
  " (in 'string', line 124, column 2 to column 51)",
  " (in 'string', line 125, column 2 to column 23)",
  " (in 'string', line 126, column 2 to column 23)",
  " (in 'string', line 127, column 8 to column 19)",
  " (in 'string', line 127, column 2 to column 36)",
  " (in 'string', line 128, column 8 to column 13)",
  " (in 'string', line 128, column 2 to column 43)",
  " (in 'string', line 129, column 8 to column 13)",
  " (in 'string', line 129, column 2 to column 57)",
  " (in 'string', line 130, column 8 to column 15)",
  " (in 'string', line 130, column 2 to column 73)",
  " (in 'string', line 132, column 2 to column 42)",
  " (in 'string', line 133, column 2 to column 42)",
  " (in 'string', line 134, column 2 to column 50)",
  " (in 'string', line 135, column 2 to column 50)",
  " (in 'string', line 149, column 2 to column 30)",
  " (in 'string', line 153, column 46 to column 107)",
  " (in 'string', line 153, column 8 to column 107)",
  " (in 'string', line 152, column 32 to column 97)",
  " (in 'string', line 152, column 3 to line 153, column 107)",
  " (in 'string', line 150, column 16 to line 154, column 3)",
  " (in 'string', line 150, column 2 to line 154, column 3)",
  " (in 'string', line 155, column 2 to column 78)",
  " (in 'string', line 156, column 2 to column 16)",
  " (in 'string', line 157, column 2 to line 162, column 25)",
  " (in 'string', line 148, column 8 to line 163, column 2)",
  " (in 'string', line 138, column 19 to column 63)",
  " (in 'string', line 138, column 4 to column 63)",
  " (in 'string', line 139, column 4 to column 32)",
  " (in 'string', line 140, column 4 to column 93)",
  " (in 'string', line 141, column 4 to column 29)",
  " (in 'string', line 142, column 4 to line 147, column 40)",
  " (in 'string', line 137, column 11 to line 148, column 2)",
  " (in 'string', line 137, column 1 to line 163, column 2)",
  " (in 'string', line 136, column 31 to line 164, column 3)",
  " (in 'string', line 136, column 2 to line 164, column 3)",
  " (in 'string', line 165, column 2 to column 18)",
  " (in 'string', line 119, column 0 to line 166, column 1)"};
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
to_triangular(const T0__& x_arg__, const int& K, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
repeat_matrix(const T0__& input_arg__, const int& K, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_row_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
repeat_rv_to_matrix(const T0__& input_arg__, const int& K, std::ostream*
                    pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_stan_scalar<T0__>>* = nullptr>
std::vector<stan::promote_args_t<T0__>>
rep_each(const std::vector<T0__>& x, const int& K, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
std::vector<stan::promote_args_t<stan::base_type_t<T0__>>>
to_vector_rowwise(const T0__& x_arg__, std::ostream* pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>* = nullptr>
std::vector<stan::promote_args_t<stan::base_type_t<T0__>>>
to_vector_colwise(const T0__& x_arg__, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T1__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>>* = nullptr>
std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__>>
ODE_states(const T0__& time, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__);
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T1__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>>* = nullptr>
std::vector<std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__, T4__>>>
integrate_ode_trapezoidal(const std::vector<T0__>& y_initial, const T1__&
                          initial_time, const std::vector<T2__>& times,
                          const std::vector<T3__>& theta,
                          const std::vector<T4__>& x_r,
                          const std::vector<int>& x_i, std::ostream*
                          pstream__);
template <typename T0__,
          stan::require_all_t<stan::is_col_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
to_triangular(const T0__& x_arg__, const int& K, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& x = stan::math::to_ref(x_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 216;
    stan::math::validate_non_negative_index("y", "K", K);
    current_statement__ = 217;
    stan::math::validate_non_negative_index("y", "K", K);
    Eigen::Matrix<local_scalar_t__,-1,-1> y =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(K, K, DUMMY_VAR__);
    current_statement__ = 218;
    stan::model::assign(y, stan::math::rep_matrix(0.0, K, K),
      "assigning variable y");
    int pos = std::numeric_limits<int>::min();
    current_statement__ = 219;
    pos = 1;
    current_statement__ = 225;
    for (int col = 1; col <= K; ++col) {
      current_statement__ = 223;
      for (int row = col; row <= K; ++row) {
        current_statement__ = 220;
        stan::model::assign(y,
          stan::model::rvalue(x, "x", stan::model::index_uni(pos)),
          "assigning variable y", stan::model::index_uni(row),
          stan::model::index_uni(col));
        current_statement__ = 221;
        pos = (pos + 1);
      }
    }
    current_statement__ = 226;
    return y;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
repeat_matrix(const T0__& input_arg__, const int& K, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& input = stan::math::to_ref(input_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int N = std::numeric_limits<int>::min();
    current_statement__ = 228;
    N = stan::math::rows(input);
    int M = std::numeric_limits<int>::min();
    current_statement__ = 229;
    M = stan::math::cols(input);
    current_statement__ = 230;
    stan::math::validate_non_negative_index("repmat", "N * K", (N * K));
    current_statement__ = 231;
    stan::math::validate_non_negative_index("repmat", "M", M);
    Eigen::Matrix<local_scalar_t__,-1,-1> repmat =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant((N * K), M,
        DUMMY_VAR__);
    int pos = std::numeric_limits<int>::min();
    current_statement__ = 233;
    pos = 1;
    current_statement__ = 239;
    for (int n = 1; n <= N; ++n) {
      current_statement__ = 237;
      for (int k = 1; k <= K; ++k) {
        current_statement__ = 234;
        stan::model::assign(repmat,
          stan::math::to_row_vector(
            stan::model::rvalue(input, "input", stan::model::index_uni(n),
              stan::model::index_omni())), "assigning variable repmat",
          stan::model::index_uni(pos), stan::model::index_omni());
        current_statement__ = 235;
        pos = (pos + 1);
      }
    }
    current_statement__ = 240;
    return repmat;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_row_vector<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
Eigen::Matrix<stan::promote_args_t<stan::base_type_t<T0__>>,-1,-1>
repeat_rv_to_matrix(const T0__& input_arg__, const int& K, std::ostream*
                    pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& input = stan::math::to_ref(input_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int M = std::numeric_limits<int>::min();
    current_statement__ = 242;
    M = stan::math::num_elements(input);
    current_statement__ = 243;
    stan::math::validate_non_negative_index("repmat", "K", K);
    current_statement__ = 244;
    stan::math::validate_non_negative_index("repmat", "M", M);
    Eigen::Matrix<local_scalar_t__,-1,-1> repmat =
      Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(K, M, DUMMY_VAR__);
    int pos = std::numeric_limits<int>::min();
    current_statement__ = 246;
    pos = 1;
    current_statement__ = 250;
    for (int k = 1; k <= K; ++k) {
      current_statement__ = 247;
      stan::model::assign(repmat, input, "assigning variable repmat",
        stan::model::index_uni(pos), stan::model::index_omni());
      current_statement__ = 248;
      pos = (pos + 1);
    }
    current_statement__ = 251;
    return repmat;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, stan::require_all_t<stan::is_stan_scalar<T0__>>*>
std::vector<stan::promote_args_t<T0__>>
rep_each(const std::vector<T0__>& x, const int& K, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int N = std::numeric_limits<int>::min();
    current_statement__ = 253;
    N = stan::math::size(x);
    current_statement__ = 254;
    stan::math::validate_non_negative_index("y", "N * K", (N * K));
    std::vector<local_scalar_t__> y =
      std::vector<local_scalar_t__>((N * K), DUMMY_VAR__);
    int pos = std::numeric_limits<int>::min();
    current_statement__ = 256;
    pos = 1;
    current_statement__ = 262;
    for (int n = 1; n <= N; ++n) {
      current_statement__ = 260;
      for (int k = 1; k <= K; ++k) {
        current_statement__ = 257;
        stan::model::assign(y,
          stan::model::rvalue(x, "x", stan::model::index_uni(n)),
          "assigning variable y", stan::model::index_uni(pos));
        current_statement__ = 258;
        pos = (pos + 1);
      }
    }
    current_statement__ = 263;
    return y;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
std::vector<stan::promote_args_t<stan::base_type_t<T0__>>>
to_vector_rowwise(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& x = stan::math::to_ref(x_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 265;
    stan::math::validate_non_negative_index("res", "num_elements(x)",
      stan::math::num_elements(x));
    std::vector<local_scalar_t__> res =
      std::vector<local_scalar_t__>(stan::math::num_elements(x), DUMMY_VAR__);
    int n = std::numeric_limits<int>::min();
    int m = std::numeric_limits<int>::min();
    current_statement__ = 269;
    n = stan::math::rows(x);
    current_statement__ = 270;
    m = stan::math::cols(x);
    current_statement__ = 273;
    for (int i = 1; i <= n; ++i) {
      current_statement__ = 272;
      for (int j = 1; j <= m; ++j) {
        current_statement__ = 271;
        stan::model::assign(res,
          stan::model::rvalue(x, "x", stan::model::index_uni(i),
            stan::model::index_uni(j)), "assigning variable res",
          stan::model::index_uni((((i - 1) * m) + j)));
      }
    }
    current_statement__ = 274;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__,
          stan::require_all_t<stan::is_eigen_matrix_dynamic<T0__>,
                              stan::is_vt_not_complex<T0__>>*>
std::vector<stan::promote_args_t<stan::base_type_t<T0__>>>
to_vector_colwise(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::base_type_t<T0__>>;
  int current_statement__ = 0;
  const auto& x = stan::math::to_ref(x_arg__);
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    current_statement__ = 276;
    stan::math::validate_non_negative_index("res", "num_elements(x)",
      stan::math::num_elements(x));
    std::vector<local_scalar_t__> res =
      std::vector<local_scalar_t__>(stan::math::num_elements(x), DUMMY_VAR__);
    int n = std::numeric_limits<int>::min();
    int m = std::numeric_limits<int>::min();
    current_statement__ = 280;
    n = stan::math::rows(x);
    current_statement__ = 281;
    m = stan::math::cols(x);
    current_statement__ = 284;
    for (int i = 1; i <= n; ++i) {
      current_statement__ = 283;
      for (int j = 1; j <= m; ++j) {
        current_statement__ = 282;
        stan::model::assign(res,
          stan::model::rvalue(x, "x", stan::model::index_uni(i),
            stan::model::index_uni(j)), "assigning variable res",
          stan::model::index_uni(((n * (j - 1)) + i)));
      }
    }
    current_statement__ = 285;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__, typename T2__, typename T3__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T1__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>>*>
std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__>>
ODE_states(const T0__& time, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    int A = std::numeric_limits<int>::min();
    current_statement__ = 287;
    A = stan::model::rvalue(x_i, "x_i", stan::model::index_uni(1));
    int n_obs = std::numeric_limits<int>::min();
    current_statement__ = 288;
    n_obs = stan::model::rvalue(x_i, "x_i", stan::model::index_uni(2));
    int n_difeq = std::numeric_limits<int>::min();
    current_statement__ = 289;
    n_difeq = stan::model::rvalue(x_i, "x_i", stan::model::index_uni(3));
    current_statement__ = 290;
    stan::math::validate_non_negative_index("dy_dt", "A * n_difeq", (A *
      n_difeq));
    std::vector<local_scalar_t__> dy_dt =
      std::vector<local_scalar_t__>((A * n_difeq), DUMMY_VAR__);
    current_statement__ = 292;
    stan::math::validate_non_negative_index("f_inf", "A", A);
    std::vector<local_scalar_t__> f_inf =
      std::vector<local_scalar_t__>(A, DUMMY_VAR__);
    current_statement__ = 294;
    stan::math::validate_non_negative_index("init", "2 * A", (2 * A));
    std::vector<local_scalar_t__> init =
      std::vector<local_scalar_t__>((2 * A), DUMMY_VAR__);
    current_statement__ = 296;
    stan::math::validate_non_negative_index("age_dist", "A", A);
    std::vector<local_scalar_t__> age_dist =
      std::vector<local_scalar_t__>(A, DUMMY_VAR__);
    current_statement__ = 297;
    stan::model::assign(age_dist,
      stan::model::rvalue(x_r, "x_r",
        stan::model::index_min_max(((2 * n_obs) + 1), ((2 * n_obs) + A))),
      "assigning variable age_dist");
    current_statement__ = 298;
    stan::math::validate_non_negative_index("contact", "A * A", (A * A));
    std::vector<local_scalar_t__> contact =
      std::vector<local_scalar_t__>((A * A), DUMMY_VAR__);
    current_statement__ = 299;
    stan::model::assign(contact,
      stan::model::rvalue(theta, "theta",
        stan::model::index_min_max(1, (A * A))), "assigning variable contact");
    local_scalar_t__ gamma = DUMMY_VAR__;
    current_statement__ = 300;
    gamma = stan::model::rvalue(theta, "theta",
              stan::model::index_uni(((A * A) + 1)));
    local_scalar_t__ tau = DUMMY_VAR__;
    current_statement__ = 301;
    tau = stan::model::rvalue(theta, "theta",
            stan::model::index_uni(((A * A) + 2)));
    local_scalar_t__ pi = DUMMY_VAR__;
    current_statement__ = 302;
    pi = stan::model::rvalue(theta, "theta",
           stan::model::index_uni(((A * A) + 3)));
    current_statement__ = 303;
    stan::math::validate_non_negative_index("beta", "A", A);
    std::vector<local_scalar_t__> beta =
      std::vector<local_scalar_t__>(A, DUMMY_VAR__);
    current_statement__ = 304;
    stan::model::assign(beta,
      stan::model::rvalue(theta, "theta",
        stan::model::index_min_max(((A * A) + 4), (((A * A) + A) + 3))),
      "assigning variable beta");
    current_statement__ = 315;
    for (int i = 1; i <= A; ++i) {
      current_statement__ = 305;
      stan::model::assign(init,
        (stan::model::rvalue(age_dist, "age_dist", stan::model::index_uni(i))
        * (1 - pi)), "assigning variable init", stan::model::index_uni(i));
      current_statement__ = 306;
      stan::model::assign(init,
        (stan::model::rvalue(age_dist, "age_dist", stan::model::index_uni(i))
        * pi), "assigning variable init", stan::model::index_uni((A + i)));
      current_statement__ = 307;
      stan::model::assign(f_inf,
        stan::math::sum(
          stan::math::elt_multiply(
            stan::math::elt_divide(
              stan::math::elt_multiply(stan::math::to_vector(beta),
                stan::math::add(
                  stan::math::to_vector(
                    stan::model::rvalue(y, "y",
                      stan::model::index_min_max(((3 * A) + 1), (4 * A)))),
                  stan::math::to_vector(
                    stan::model::rvalue(y, "y",
                      stan::model::index_min_max(((4 * A) + 1), (5 * A)))))),
              stan::math::to_vector(age_dist)),
            stan::math::to_vector(
              stan::model::rvalue(contact, "contact",
                stan::model::index_min_max(((A * (i - 1)) + 1), (i * A)))))),
        "assigning variable f_inf", stan::model::index_uni(i));
      current_statement__ = 308;
      stan::model::assign(dy_dt,
        (-stan::model::rvalue(f_inf, "f_inf", stan::model::index_uni(i)) *
        (stan::model::rvalue(y, "y", stan::model::index_uni(i)) +
        stan::model::rvalue(init, "init", stan::model::index_uni(i)))),
        "assigning variable dy_dt", stan::model::index_uni(i));
      current_statement__ = 309;
      stan::model::assign(dy_dt,
        ((stan::model::rvalue(f_inf, "f_inf", stan::model::index_uni(i)) *
        (stan::model::rvalue(y, "y", stan::model::index_uni(i)) +
        stan::model::rvalue(init, "init", stan::model::index_uni(i)))) - (tau
        * (stan::model::rvalue(y, "y", stan::model::index_uni((A + i))) +
        stan::model::rvalue(init, "init", stan::model::index_uni((A + i)))))),
        "assigning variable dy_dt", stan::model::index_uni((A + i)));
      current_statement__ = 310;
      stan::model::assign(dy_dt, (tau *
        ((stan::model::rvalue(y, "y", stan::model::index_uni((A + i))) +
        stan::model::rvalue(init, "init", stan::model::index_uni((A + i)))) -
        stan::model::rvalue(y, "y", stan::model::index_uni(((2 * A) + i))))),
        "assigning variable dy_dt", stan::model::index_uni(((2 * A) + i)));
      current_statement__ = 311;
      stan::model::assign(dy_dt, ((tau *
        stan::model::rvalue(y, "y", stan::model::index_uni(((2 * A) + i)))) -
        (gamma *
        stan::model::rvalue(y, "y", stan::model::index_uni(((3 * A) + i))))),
        "assigning variable dy_dt", stan::model::index_uni(((3 * A) + i)));
      current_statement__ = 312;
      stan::model::assign(dy_dt, (gamma *
        (stan::model::rvalue(y, "y", stan::model::index_uni(((3 * A) + i))) -
        (gamma *
        stan::model::rvalue(y, "y", stan::model::index_uni(((4 * A) + i)))))),
        "assigning variable dy_dt", stan::model::index_uni(((4 * A) + i)));
      current_statement__ = 313;
      stan::model::assign(dy_dt, (tau *
        stan::model::rvalue(y, "y", stan::model::index_uni(((2 * A) + i)))),
        "assigning variable dy_dt",
        stan::model::index_uni((((n_difeq - 1) * A) + i)));
    }
    current_statement__ = 316;
    return dy_dt;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
template <typename T0__, typename T1__, typename T2__, typename T3__,
          typename T4__,
          stan::require_all_t<stan::is_stan_scalar<T0__>,
                              stan::is_stan_scalar<T1__>,
                              stan::is_stan_scalar<T2__>,
                              stan::is_stan_scalar<T3__>,
                              stan::is_stan_scalar<T4__>>*>
std::vector<std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__, T4__>>>
integrate_ode_trapezoidal(const std::vector<T0__>& y_initial, const T1__&
                          initial_time, const std::vector<T2__>& times,
                          const std::vector<T3__>& theta,
                          const std::vector<T4__>& x_r,
                          const std::vector<int>& x_i, std::ostream*
                          pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__, T4__>;
  int current_statement__ = 0;
  static constexpr bool propto__ = true;
  // suppress unused var warning
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  // suppress unused var warning
  (void) DUMMY_VAR__;
  try {
    local_scalar_t__ h = DUMMY_VAR__;
    current_statement__ = 319;
    stan::math::validate_non_negative_index("dy_dt_initial_time",
      "size(y_initial)", stan::math::size(y_initial));
    Eigen::Matrix<local_scalar_t__,-1,1> dy_dt_initial_time =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(stan::math::size(
                                                       y_initial),
        DUMMY_VAR__);
    current_statement__ = 321;
    stan::math::validate_non_negative_index("dy_dt_t", "size(y_initial)",
      stan::math::size(y_initial));
    Eigen::Matrix<local_scalar_t__,-1,1> dy_dt_t =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(stan::math::size(
                                                       y_initial),
        DUMMY_VAR__);
    current_statement__ = 323;
    stan::math::validate_non_negative_index("k", "size(y_initial)",
      stan::math::size(y_initial));
    Eigen::Matrix<local_scalar_t__,-1,1> k =
      Eigen::Matrix<local_scalar_t__,-1,1>::Constant(stan::math::size(
                                                       y_initial),
        DUMMY_VAR__);
    current_statement__ = 325;
    stan::math::validate_non_negative_index("y_approx", "size(times)",
      stan::math::size(times));
    current_statement__ = 326;
    stan::math::validate_non_negative_index("y_approx", "size(y_initial)",
      stan::math::size(y_initial));
    std::vector<std::vector<local_scalar_t__>> y_approx =
      std::vector<std::vector<local_scalar_t__>>(stan::math::size(times),
        std::vector<local_scalar_t__>(stan::math::size(y_initial),
          DUMMY_VAR__));
    int A = std::numeric_limits<int>::min();
    current_statement__ = 328;
    A = stan::model::rvalue(x_i, "x_i", stan::model::index_uni(1));
    int n_obs = std::numeric_limits<int>::min();
    current_statement__ = 329;
    n_obs = stan::model::rvalue(x_i, "x_i", stan::model::index_uni(2));
    current_statement__ = 330;
    stan::math::validate_non_negative_index("theta_ODE", "A * A + A + 3",
      (((A * A) + A) + 3));
    std::vector<local_scalar_t__> theta_ODE =
      std::vector<local_scalar_t__>((((A * A) + A) + 3), DUMMY_VAR__);
    current_statement__ = 332;
    stan::math::validate_non_negative_index("left_t", "n_obs", n_obs);
    std::vector<local_scalar_t__> left_t =
      std::vector<local_scalar_t__>(n_obs, DUMMY_VAR__);
    current_statement__ = 333;
    stan::model::assign(left_t,
      stan::model::rvalue(x_r, "x_r", stan::model::index_min_max(1, n_obs)),
      "assigning variable left_t");
    current_statement__ = 334;
    stan::math::validate_non_negative_index("right_t", "n_obs", n_obs);
    std::vector<local_scalar_t__> right_t =
      std::vector<local_scalar_t__>(n_obs, DUMMY_VAR__);
    current_statement__ = 335;
    stan::model::assign(right_t,
      stan::model::rvalue(x_r, "x_r",
        stan::model::index_min_max((n_obs + 1), (2 * n_obs))),
      "assigning variable right_t");
    current_statement__ = 336;
    stan::math::validate_non_negative_index("beta_N_temp", "A * n_obs", (A *
      n_obs));
    std::vector<local_scalar_t__> beta_N_temp =
      std::vector<local_scalar_t__>((A * n_obs), DUMMY_VAR__);
    current_statement__ = 337;
    stan::model::assign(beta_N_temp,
      stan::model::rvalue(theta, "theta",
        stan::model::index_min_max(((A * A) + 3), (((A * n_obs) + (A * A)) +
          2))), "assigning variable beta_N_temp");
    current_statement__ = 338;
    stan::model::assign(theta_ODE,
      stan::model::rvalue(theta, "theta",
        stan::model::index_min_max(1, (A * A))),
      "assigning variable theta_ODE", stan::model::index_min_max(1, (A * A)));
    current_statement__ = 339;
    stan::model::assign(theta_ODE,
      stan::model::rvalue(theta, "theta",
        stan::model::index_uni(((A * A) + 1))),
      "assigning variable theta_ODE", stan::model::index_uni(((A * A) + 1)));
    current_statement__ = 340;
    stan::model::assign(theta_ODE,
      stan::model::rvalue(theta, "theta",
        stan::model::index_uni((((A * n_obs) + (A * A)) + 4))),
      "assigning variable theta_ODE", stan::model::index_uni(((A * A) + 2)));
    current_statement__ = 341;
    stan::model::assign(theta_ODE,
      stan::model::rvalue(theta, "theta",
        stan::model::index_uni((((A * n_obs) + (A * A)) + 3))),
      "assigning variable theta_ODE", stan::model::index_uni(((A * A) + 3)));
    current_statement__ = 362;
    for (int t = 0; t <= (stan::math::size(times) - 1); ++t) {
      current_statement__ = 360;
      if (stan::math::logical_eq(t, 0)) {
        current_statement__ = 354;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 353;
          stan::model::assign(theta_ODE,
            stan::model::rvalue(theta, "theta",
              stan::model::index_uni(((A * A) + 2))),
            "assigning variable theta_ODE",
            stan::model::index_uni((((A * A) + 3) + j)));
        }
        current_statement__ = 355;
        h = (stan::model::rvalue(times, "times", stan::model::index_uni(1)) -
          initial_time);
        current_statement__ = 356;
        stan::model::assign(dy_dt_initial_time,
          stan::math::to_vector(
            ODE_states(initial_time, y_initial, theta_ODE, x_r, x_i,
              pstream__)), "assigning variable dy_dt_initial_time");
        current_statement__ = 357;
        stan::model::assign(k, stan::math::multiply(h, dy_dt_initial_time),
          "assigning variable k");
        current_statement__ = 358;
        stan::model::assign(y_approx,
          stan::math::to_array_1d(
            stan::math::add(stan::math::to_vector(y_initial),
              stan::math::divide(
                stan::math::multiply(h,
                  stan::math::add(dy_dt_initial_time,
                    stan::math::to_vector(
                      ODE_states(
                        stan::model::rvalue(times, "times",
                          stan::model::index_uni(1)),
                        stan::math::to_array_1d(
                          stan::math::add(stan::math::to_vector(y_initial), k)),
                        theta_ODE, x_r, x_i, pstream__)))), 2))),
          "assigning variable y_approx", stan::model::index_uni((t + 1)),
          stan::model::index_omni());
      } else {
        current_statement__ = 342;
        h = (stan::model::rvalue(times, "times",
               stan::model::index_uni((t + 1)))
          - stan::model::rvalue(times, "times", stan::model::index_uni(t)));
        current_statement__ = 348;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 346;
          if (stan::math::logical_eq(t, (stan::math::size(times) - 1))) {
            current_statement__ = 345;
            stan::model::assign(theta_ODE,
              stan::model::rvalue(beta_N_temp, "beta_N_temp",
                stan::model::index_uni((((n_obs * (j - 1)) + t) + 1))),
              "assigning variable theta_ODE",
              stan::model::index_uni((((A * A) + 3) + j)));
          } else {
            current_statement__ = 344;
            if ((stan::math::primitive_value(
                   stan::math::logical_gte(t,
                     stan::model::rvalue(left_t, "left_t",
                       stan::model::index_uni(t))))
                &&
                stan::math::primitive_value(
                  stan::math::logical_lte(t,
                    stan::model::rvalue(right_t, "right_t",
                      stan::model::index_uni(t)))))) {
              current_statement__ = 343;
              stan::model::assign(theta_ODE,
                stan::model::rvalue(beta_N_temp, "beta_N_temp",
                  stan::model::index_uni(((n_obs * (j - 1)) + t))),
                "assigning variable theta_ODE",
                stan::model::index_uni((((A * A) + 3) + j)));
            }
          }
        }
        current_statement__ = 349;
        stan::model::assign(dy_dt_t,
          stan::math::to_vector(
            ODE_states(
              stan::model::rvalue(times, "times", stan::model::index_uni(t)),
              stan::model::rvalue(y_approx, "y_approx",
                stan::model::index_uni(t)), theta_ODE, x_r, x_i, pstream__)),
          "assigning variable dy_dt_t");
        current_statement__ = 350;
        stan::model::assign(k, stan::math::multiply(h, dy_dt_t),
          "assigning variable k");
        current_statement__ = 351;
        stan::model::assign(y_approx,
          stan::math::to_array_1d(
            stan::math::add(
              stan::math::to_vector(
                stan::model::deep_copy(
                  stan::model::rvalue(y_approx, "y_approx",
                    stan::model::index_uni(t), stan::model::index_omni()))),
              stan::math::divide(
                stan::math::multiply(h,
                  stan::math::add(dy_dt_t,
                    stan::math::to_vector(
                      ODE_states(
                        stan::model::rvalue(times, "times",
                          stan::model::index_uni((t + 1))),
                        stan::math::to_array_1d(
                          stan::math::add(
                            stan::math::to_vector(
                              stan::model::deep_copy(
                                stan::model::rvalue(y_approx, "y_approx",
                                  stan::model::index_uni(t),
                                  stan::model::index_omni()))), k)),
                        theta_ODE, x_r, x_i, pstream__)))), 2))),
          "assigning variable y_approx", stan::model::index_uni((t + 1)),
          stan::model::index_omni());
      }
    }
    current_statement__ = 363;
    return y_approx;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
}
#include <stan_meta_header.hpp>
class model_igbm final : public model_base_crtp<model_igbm> {
private:
  int A;
  int n_obs;
  std::vector<std::vector<int>> y_data;
  int n_pop;
  int ecr_changes;
  int n_changes;
  int n_remainder;
  int L_raw_length;
  std::vector<double> age_dist;
  Eigen::Matrix<double,-1,1> pop_diag_data__;
  int n_difeq;
  std::vector<Eigen::Matrix<double,-1,1>> L_cm;
  std::vector<std::vector<double>> age_specific_ifr;
  double t0;
  std::vector<double> ts;
  std::vector<double> left_t;
  std::vector<double> right_t;
  Eigen::Matrix<double,-1,1> I_D_data__;
  Eigen::Matrix<double,1,-1> E_deathsByAge_day1_data__;
  double incubation_period;
  double infectious_period;
  int likelihood_variance_type;
  int prior_dist_volatility;
  double prior_mean_volatility;
  double prior_scale_volatility;
  double prior_df_volatility;
  double prior_shape_volatility;
  double prior_rate_volatility;
  int prior_dist_nb_dispersion;
  double prior_mean_nb_dispersion;
  double prior_scale_nb_dispersion;
  double prior_df_nb_dispersion;
  double prior_shape_nb_dispersion;
  double prior_rate_nb_dispersion;
  double prior_scale_x0;
  double prior_scale_x1;
  double prior_scale_contactmatrix;
  Eigen::Matrix<double,-1,-1> prior_dist_pi_data__;
  Eigen::Matrix<double,-1,1> I_D_rev_data__;
  std::vector<int> x_i;
  std::vector<double> x_r;
  double gamma;
  double tau;
  std::vector<double> init;
  Eigen::Matrix<double,-1,1> ones_vector_A_data__;
  Eigen::Matrix<double,-1,1> L_vector_data__;
  int x_noise_1dim__;
  int beta_N_1dim__;
  int theta_1dim__;
  int state_solutions_2dim__;
  int x_noise_mat_1dim__;
  Eigen::Map<Eigen::Matrix<double,-1,1>> pop_diag{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> I_D{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,1,-1>> E_deathsByAge_day1{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,-1>> prior_dist_pi{nullptr, 0, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> I_D_rev{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> ones_vector_A{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double,-1,1>> L_vector{nullptr, 0};
public:
  ~model_igbm() {}
  model_igbm(stan::io::var_context& context__, unsigned int
             random_seed__ = 0, std::ostream* pstream__ = nullptr)
      : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double;
    boost::ecuyer1988 base_rng__ =
      stan::services::util::create_rng(random_seed__, 0);
    // suppress unused var warning
    (void) base_rng__;
    static constexpr const char* function__ =
      "model_igbm_namespace::model_igbm";
    // suppress unused var warning
    (void) function__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      current_statement__ = 107;
      context__.validate_dims("data initialization", "A", "int",
        std::vector<size_t>{});
      A = std::numeric_limits<int>::min();
      current_statement__ = 107;
      A = context__.vals_i("A")[(1 - 1)];
      current_statement__ = 108;
      context__.validate_dims("data initialization", "n_obs", "int",
        std::vector<size_t>{});
      n_obs = std::numeric_limits<int>::min();
      current_statement__ = 108;
      n_obs = context__.vals_i("n_obs")[(1 - 1)];
      current_statement__ = 109;
      stan::math::validate_non_negative_index("y_data", "n_obs", n_obs);
      current_statement__ = 110;
      stan::math::validate_non_negative_index("y_data", "A", A);
      current_statement__ = 111;
      context__.validate_dims("data initialization", "y_data", "int",
        std::vector<size_t>{static_cast<size_t>(n_obs),
          static_cast<size_t>(A)});
      y_data = std::vector<std::vector<int>>(n_obs,
                 std::vector<int>(A, std::numeric_limits<int>::min()));
      {
        std::vector<int> y_data_flat__;
        current_statement__ = 111;
        y_data_flat__ = context__.vals_i("y_data");
        current_statement__ = 111;
        pos__ = 1;
        current_statement__ = 111;
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          current_statement__ = 111;
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            current_statement__ = 111;
            stan::model::assign(y_data, y_data_flat__[(pos__ - 1)],
              "assigning variable y_data", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 111;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 112;
      context__.validate_dims("data initialization", "n_pop", "int",
        std::vector<size_t>{});
      n_pop = std::numeric_limits<int>::min();
      current_statement__ = 112;
      n_pop = context__.vals_i("n_pop")[(1 - 1)];
      current_statement__ = 112;
      stan::math::check_greater_or_equal(function__, "n_pop", n_pop, 1);
      current_statement__ = 113;
      context__.validate_dims("data initialization", "ecr_changes", "int",
        std::vector<size_t>{});
      ecr_changes = std::numeric_limits<int>::min();
      current_statement__ = 113;
      ecr_changes = context__.vals_i("ecr_changes")[(1 - 1)];
      current_statement__ = 113;
      stan::math::check_greater_or_equal(function__, "ecr_changes",
        ecr_changes, 1);
      current_statement__ = 113;
      stan::math::check_less_or_equal(function__, "ecr_changes", ecr_changes,
        7);
      current_statement__ = 114;
      context__.validate_dims("data initialization", "n_changes", "int",
        std::vector<size_t>{});
      n_changes = std::numeric_limits<int>::min();
      current_statement__ = 114;
      n_changes = context__.vals_i("n_changes")[(1 - 1)];
      current_statement__ = 115;
      context__.validate_dims("data initialization", "n_remainder", "int",
        std::vector<size_t>{});
      n_remainder = std::numeric_limits<int>::min();
      current_statement__ = 115;
      n_remainder = context__.vals_i("n_remainder")[(1 - 1)];
      current_statement__ = 116;
      context__.validate_dims("data initialization", "L_raw_length", "int",
        std::vector<size_t>{});
      L_raw_length = std::numeric_limits<int>::min();
      current_statement__ = 116;
      L_raw_length = context__.vals_i("L_raw_length")[(1 - 1)];
      current_statement__ = 117;
      stan::math::validate_non_negative_index("age_dist", "A", A);
      current_statement__ = 118;
      context__.validate_dims("data initialization", "age_dist", "double",
        std::vector<size_t>{static_cast<size_t>(A)});
      age_dist = std::vector<double>(A,
                   std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 118;
      age_dist = context__.vals_r("age_dist");
      current_statement__ = 119;
      stan::math::validate_non_negative_index("pop_diag", "A", A);
      current_statement__ = 120;
      context__.validate_dims("data initialization", "pop_diag", "double",
        std::vector<size_t>{static_cast<size_t>(A)});
      pop_diag_data__ = Eigen::Matrix<double,-1,1>::Constant(A,
                          std::numeric_limits<double>::quiet_NaN());
      new (&pop_diag)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(pop_diag_data__.data(), A);
      {
        std::vector<local_scalar_t__> pop_diag_flat__;
        current_statement__ = 120;
        pop_diag_flat__ = context__.vals_r("pop_diag");
        current_statement__ = 120;
        pos__ = 1;
        current_statement__ = 120;
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          current_statement__ = 120;
          stan::model::assign(pop_diag, pop_diag_flat__[(pos__ - 1)],
            "assigning variable pop_diag", stan::model::index_uni(sym1__));
          current_statement__ = 120;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 121;
      context__.validate_dims("data initialization", "n_difeq", "int",
        std::vector<size_t>{});
      n_difeq = std::numeric_limits<int>::min();
      current_statement__ = 121;
      n_difeq = context__.vals_i("n_difeq")[(1 - 1)];
      current_statement__ = 121;
      stan::math::check_greater_or_equal(function__, "n_difeq", n_difeq, 1);
      current_statement__ = 122;
      stan::math::validate_non_negative_index("L_cm", "A", A);
      current_statement__ = 123;
      stan::math::validate_non_negative_index("L_cm", "A", A);
      current_statement__ = 124;
      context__.validate_dims("data initialization", "L_cm", "double",
        std::vector<size_t>{static_cast<size_t>(A), static_cast<size_t>(A)});
      L_cm = std::vector<Eigen::Matrix<double,-1,1>>(A,
               Eigen::Matrix<double,-1,1>::Constant(A,
                 std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> L_cm_flat__;
        current_statement__ = 124;
        L_cm_flat__ = context__.vals_r("L_cm");
        current_statement__ = 124;
        pos__ = 1;
        current_statement__ = 124;
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          current_statement__ = 124;
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            current_statement__ = 124;
            stan::model::assign(L_cm, L_cm_flat__[(pos__ - 1)],
              "assigning variable L_cm", stan::model::index_uni(sym2__),
              stan::model::index_uni(sym1__));
            current_statement__ = 124;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 125;
      stan::math::validate_non_negative_index("age_specific_ifr", "n_obs",
        n_obs);
      current_statement__ = 126;
      stan::math::validate_non_negative_index("age_specific_ifr", "A", A);
      current_statement__ = 127;
      context__.validate_dims("data initialization", "age_specific_ifr",
        "double",
        std::vector<size_t>{static_cast<size_t>(n_obs),
          static_cast<size_t>(A)});
      age_specific_ifr = std::vector<std::vector<double>>(n_obs,
                           std::vector<double>(A,
                             std::numeric_limits<double>::quiet_NaN()));
      {
        std::vector<local_scalar_t__> age_specific_ifr_flat__;
        current_statement__ = 127;
        age_specific_ifr_flat__ = context__.vals_r("age_specific_ifr");
        current_statement__ = 127;
        pos__ = 1;
        current_statement__ = 127;
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          current_statement__ = 127;
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            current_statement__ = 127;
            stan::model::assign(age_specific_ifr,
              age_specific_ifr_flat__[(pos__ - 1)],
              "assigning variable age_specific_ifr",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 127;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 127;
      stan::math::check_greater_or_equal(function__, "age_specific_ifr",
        age_specific_ifr, 0);
      current_statement__ = 127;
      stan::math::check_less_or_equal(function__, "age_specific_ifr",
        age_specific_ifr, 1);
      current_statement__ = 128;
      context__.validate_dims("data initialization", "t0", "double",
        std::vector<size_t>{});
      t0 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 128;
      t0 = context__.vals_r("t0")[(1 - 1)];
      current_statement__ = 129;
      stan::math::validate_non_negative_index("ts", "n_obs", n_obs);
      current_statement__ = 130;
      context__.validate_dims("data initialization", "ts", "double",
        std::vector<size_t>{static_cast<size_t>(n_obs)});
      ts = std::vector<double>(n_obs,
             std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 130;
      ts = context__.vals_r("ts");
      current_statement__ = 131;
      stan::math::validate_non_negative_index("left_t", "n_obs", n_obs);
      current_statement__ = 132;
      context__.validate_dims("data initialization", "left_t", "double",
        std::vector<size_t>{static_cast<size_t>(n_obs)});
      left_t = std::vector<double>(n_obs,
                 std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 132;
      left_t = context__.vals_r("left_t");
      current_statement__ = 132;
      stan::math::check_greater_or_equal(function__, "left_t", left_t, 0);
      current_statement__ = 133;
      stan::math::validate_non_negative_index("right_t", "n_obs", n_obs);
      current_statement__ = 134;
      context__.validate_dims("data initialization", "right_t", "double",
        std::vector<size_t>{static_cast<size_t>(n_obs)});
      right_t = std::vector<double>(n_obs,
                  std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 134;
      right_t = context__.vals_r("right_t");
      current_statement__ = 134;
      stan::math::check_greater_or_equal(function__, "right_t", right_t, 0);
      current_statement__ = 135;
      stan::math::validate_non_negative_index("I_D", "n_obs", n_obs);
      current_statement__ = 136;
      context__.validate_dims("data initialization", "I_D", "double",
        std::vector<size_t>{static_cast<size_t>(n_obs)});
      I_D_data__ = Eigen::Matrix<double,-1,1>::Constant(n_obs,
                     std::numeric_limits<double>::quiet_NaN());
      new (&I_D) Eigen::Map<Eigen::Matrix<double,-1,1>>(I_D_data__.data(),
        n_obs);
      {
        std::vector<local_scalar_t__> I_D_flat__;
        current_statement__ = 136;
        I_D_flat__ = context__.vals_r("I_D");
        current_statement__ = 136;
        pos__ = 1;
        current_statement__ = 136;
        for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
          current_statement__ = 136;
          stan::model::assign(I_D, I_D_flat__[(pos__ - 1)],
            "assigning variable I_D", stan::model::index_uni(sym1__));
          current_statement__ = 136;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 136;
      stan::math::check_greater_or_equal(function__, "I_D", I_D, 0);
      current_statement__ = 137;
      stan::math::validate_non_negative_index("E_deathsByAge_day1", "A", A);
      current_statement__ = 138;
      context__.validate_dims("data initialization", "E_deathsByAge_day1",
        "double", std::vector<size_t>{static_cast<size_t>(A)});
      E_deathsByAge_day1_data__ = Eigen::Matrix<double,1,-1>::Constant(A,
                                    std::numeric_limits<double>::quiet_NaN());
      new (&E_deathsByAge_day1)
        Eigen::Map<Eigen::Matrix<double,1,-1>>(E_deathsByAge_day1_data__.data(),
        A);
      {
        std::vector<local_scalar_t__> E_deathsByAge_day1_flat__;
        current_statement__ = 138;
        E_deathsByAge_day1_flat__ = context__.vals_r("E_deathsByAge_day1");
        current_statement__ = 138;
        pos__ = 1;
        current_statement__ = 138;
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          current_statement__ = 138;
          stan::model::assign(E_deathsByAge_day1,
            E_deathsByAge_day1_flat__[(pos__ - 1)],
            "assigning variable E_deathsByAge_day1",
            stan::model::index_uni(sym1__));
          current_statement__ = 138;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 139;
      context__.validate_dims("data initialization", "incubation_period",
        "double", std::vector<size_t>{});
      incubation_period = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 139;
      incubation_period = context__.vals_r("incubation_period")[(1 - 1)];
      current_statement__ = 140;
      context__.validate_dims("data initialization", "infectious_period",
        "double", std::vector<size_t>{});
      infectious_period = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 140;
      infectious_period = context__.vals_r("infectious_period")[(1 - 1)];
      current_statement__ = 141;
      context__.validate_dims("data initialization",
        "likelihood_variance_type", "int", std::vector<size_t>{});
      likelihood_variance_type = std::numeric_limits<int>::min();
      current_statement__ = 141;
      likelihood_variance_type = context__.vals_i("likelihood_variance_type")[(1
        - 1)];
      current_statement__ = 141;
      stan::math::check_greater_or_equal(function__,
        "likelihood_variance_type", likelihood_variance_type, 0);
      current_statement__ = 141;
      stan::math::check_less_or_equal(function__, "likelihood_variance_type",
        likelihood_variance_type, 1);
      current_statement__ = 142;
      context__.validate_dims("data initialization", "prior_dist_volatility",
        "int", std::vector<size_t>{});
      prior_dist_volatility = std::numeric_limits<int>::min();
      current_statement__ = 142;
      prior_dist_volatility = context__.vals_i("prior_dist_volatility")[(1 -
        1)];
      current_statement__ = 142;
      stan::math::check_greater_or_equal(function__, "prior_dist_volatility",
        prior_dist_volatility, 1);
      current_statement__ = 142;
      stan::math::check_less_or_equal(function__, "prior_dist_volatility",
        prior_dist_volatility, 5);
      current_statement__ = 143;
      context__.validate_dims("data initialization", "prior_mean_volatility",
        "double", std::vector<size_t>{});
      prior_mean_volatility = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 143;
      prior_mean_volatility = context__.vals_r("prior_mean_volatility")[(1 -
        1)];
      current_statement__ = 143;
      stan::math::check_greater_or_equal(function__, "prior_mean_volatility",
        prior_mean_volatility, 0);
      current_statement__ = 144;
      context__.validate_dims("data initialization",
        "prior_scale_volatility", "double", std::vector<size_t>{});
      prior_scale_volatility = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 144;
      prior_scale_volatility = context__.vals_r("prior_scale_volatility")[(1
        - 1)];
      current_statement__ = 144;
      stan::math::check_greater_or_equal(function__,
        "prior_scale_volatility", prior_scale_volatility, 0);
      current_statement__ = 145;
      context__.validate_dims("data initialization", "prior_df_volatility",
        "double", std::vector<size_t>{});
      prior_df_volatility = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 145;
      prior_df_volatility = context__.vals_r("prior_df_volatility")[(1 - 1)];
      current_statement__ = 145;
      stan::math::check_greater_or_equal(function__, "prior_df_volatility",
        prior_df_volatility, 0);
      current_statement__ = 146;
      context__.validate_dims("data initialization",
        "prior_shape_volatility", "double", std::vector<size_t>{});
      prior_shape_volatility = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 146;
      prior_shape_volatility = context__.vals_r("prior_shape_volatility")[(1
        - 1)];
      current_statement__ = 146;
      stan::math::check_greater_or_equal(function__,
        "prior_shape_volatility", prior_shape_volatility, 0);
      current_statement__ = 147;
      context__.validate_dims("data initialization", "prior_rate_volatility",
        "double", std::vector<size_t>{});
      prior_rate_volatility = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 147;
      prior_rate_volatility = context__.vals_r("prior_rate_volatility")[(1 -
        1)];
      current_statement__ = 147;
      stan::math::check_greater_or_equal(function__, "prior_rate_volatility",
        prior_rate_volatility, 0);
      current_statement__ = 148;
      context__.validate_dims("data initialization",
        "prior_dist_nb_dispersion", "int", std::vector<size_t>{});
      prior_dist_nb_dispersion = std::numeric_limits<int>::min();
      current_statement__ = 148;
      prior_dist_nb_dispersion = context__.vals_i("prior_dist_nb_dispersion")[(1
        - 1)];
      current_statement__ = 148;
      stan::math::check_greater_or_equal(function__,
        "prior_dist_nb_dispersion", prior_dist_nb_dispersion, 1);
      current_statement__ = 148;
      stan::math::check_less_or_equal(function__, "prior_dist_nb_dispersion",
        prior_dist_nb_dispersion, 5);
      current_statement__ = 149;
      context__.validate_dims("data initialization",
        "prior_mean_nb_dispersion", "double", std::vector<size_t>{});
      prior_mean_nb_dispersion = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 149;
      prior_mean_nb_dispersion = context__.vals_r("prior_mean_nb_dispersion")[(1
        - 1)];
      current_statement__ = 149;
      stan::math::check_greater_or_equal(function__,
        "prior_mean_nb_dispersion", prior_mean_nb_dispersion, 0);
      current_statement__ = 150;
      context__.validate_dims("data initialization",
        "prior_scale_nb_dispersion", "double", std::vector<size_t>{});
      prior_scale_nb_dispersion = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 150;
      prior_scale_nb_dispersion = context__.vals_r("prior_scale_nb_dispersion")[(1
        - 1)];
      current_statement__ = 150;
      stan::math::check_greater_or_equal(function__,
        "prior_scale_nb_dispersion", prior_scale_nb_dispersion, 0);
      current_statement__ = 151;
      context__.validate_dims("data initialization",
        "prior_df_nb_dispersion", "double", std::vector<size_t>{});
      prior_df_nb_dispersion = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 151;
      prior_df_nb_dispersion = context__.vals_r("prior_df_nb_dispersion")[(1
        - 1)];
      current_statement__ = 151;
      stan::math::check_greater_or_equal(function__,
        "prior_df_nb_dispersion", prior_df_nb_dispersion, 0);
      current_statement__ = 152;
      context__.validate_dims("data initialization",
        "prior_shape_nb_dispersion", "double", std::vector<size_t>{});
      prior_shape_nb_dispersion = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 152;
      prior_shape_nb_dispersion = context__.vals_r("prior_shape_nb_dispersion")[(1
        - 1)];
      current_statement__ = 152;
      stan::math::check_greater_or_equal(function__,
        "prior_shape_nb_dispersion", prior_shape_nb_dispersion, 0);
      current_statement__ = 153;
      context__.validate_dims("data initialization",
        "prior_rate_nb_dispersion", "double", std::vector<size_t>{});
      prior_rate_nb_dispersion = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 153;
      prior_rate_nb_dispersion = context__.vals_r("prior_rate_nb_dispersion")[(1
        - 1)];
      current_statement__ = 153;
      stan::math::check_greater_or_equal(function__,
        "prior_rate_nb_dispersion", prior_rate_nb_dispersion, 0);
      current_statement__ = 154;
      context__.validate_dims("data initialization", "prior_scale_x0",
        "double", std::vector<size_t>{});
      prior_scale_x0 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 154;
      prior_scale_x0 = context__.vals_r("prior_scale_x0")[(1 - 1)];
      current_statement__ = 154;
      stan::math::check_greater_or_equal(function__, "prior_scale_x0",
        prior_scale_x0, 0);
      current_statement__ = 155;
      context__.validate_dims("data initialization", "prior_scale_x1",
        "double", std::vector<size_t>{});
      prior_scale_x1 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 155;
      prior_scale_x1 = context__.vals_r("prior_scale_x1")[(1 - 1)];
      current_statement__ = 155;
      stan::math::check_greater_or_equal(function__, "prior_scale_x1",
        prior_scale_x1, 0);
      current_statement__ = 156;
      context__.validate_dims("data initialization",
        "prior_scale_contactmatrix", "double", std::vector<size_t>{});
      prior_scale_contactmatrix = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 156;
      prior_scale_contactmatrix = context__.vals_r("prior_scale_contactmatrix")[(1
        - 1)];
      current_statement__ = 156;
      stan::math::check_greater_or_equal(function__,
        "prior_scale_contactmatrix", prior_scale_contactmatrix, 0);
      current_statement__ = 157;
      context__.validate_dims("data initialization", "prior_dist_pi",
        "double",
        std::vector<size_t>{static_cast<size_t>(1), static_cast<size_t>(2)});
      prior_dist_pi_data__ = Eigen::Matrix<double,-1,-1>::Constant(1, 2,
                               std::numeric_limits<double>::quiet_NaN());
      new (&prior_dist_pi)
        Eigen::Map<Eigen::Matrix<double,-1,-1>>(prior_dist_pi_data__.data(),
        1, 2);
      {
        std::vector<local_scalar_t__> prior_dist_pi_flat__;
        current_statement__ = 157;
        prior_dist_pi_flat__ = context__.vals_r("prior_dist_pi");
        current_statement__ = 157;
        pos__ = 1;
        current_statement__ = 157;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 157;
          for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
            current_statement__ = 157;
            stan::model::assign(prior_dist_pi, prior_dist_pi_flat__[(pos__ -
              1)], "assigning variable prior_dist_pi",
              stan::model::index_uni(sym2__), stan::model::index_uni(sym1__));
            current_statement__ = 157;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 157;
      stan::math::check_greater_or_equal(function__, "prior_dist_pi",
        prior_dist_pi, 0);
      current_statement__ = 158;
      stan::math::validate_non_negative_index("I_D_rev", "n_obs", n_obs);
      current_statement__ = 159;
      I_D_rev_data__ = Eigen::Matrix<double,-1,1>::Constant(n_obs,
                         std::numeric_limits<double>::quiet_NaN());
      new (&I_D_rev)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(I_D_rev_data__.data(), n_obs);
      current_statement__ = 160;
      x_i = std::vector<int>(3, std::numeric_limits<int>::min());
      current_statement__ = 161;
      stan::math::validate_non_negative_index("x_r", "2 * n_obs + A", ((2 *
        n_obs) + A));
      current_statement__ = 162;
      x_r = std::vector<double>(((2 * n_obs) + A),
              std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 163;
      gamma = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 164;
      tau = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 165;
      stan::math::validate_non_negative_index("init", "A * n_difeq", (A *
        n_difeq));
      current_statement__ = 166;
      init = std::vector<double>((A * n_difeq),
               std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 166;
      stan::model::assign(init, stan::math::rep_array(0.0, (A * n_difeq)),
        "assigning variable init");
      current_statement__ = 167;
      stan::math::validate_non_negative_index("ones_vector_A", "A", A);
      current_statement__ = 168;
      ones_vector_A_data__ = Eigen::Matrix<double,-1,1>::Constant(A,
                               std::numeric_limits<double>::quiet_NaN());
      new (&ones_vector_A)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(ones_vector_A_data__.data(),
        A);
      current_statement__ = 168;
      stan::model::assign(ones_vector_A, stan::math::rep_vector(1.0, A),
        "assigning variable ones_vector_A");
      current_statement__ = 169;
      stan::math::validate_non_negative_index("L_vector", "L_raw_length",
        L_raw_length);
      current_statement__ = 170;
      L_vector_data__ = Eigen::Matrix<double,-1,1>::Constant(L_raw_length,
                          std::numeric_limits<double>::quiet_NaN());
      new (&L_vector)
        Eigen::Map<Eigen::Matrix<double,-1,1>>(L_vector_data__.data(),
        L_raw_length);
      current_statement__ = 170;
      stan::model::assign(L_vector, stan::math::rep_vector(0, L_raw_length),
        "assigning variable L_vector");
      current_statement__ = 172;
      for (int t = 1; t <= n_obs; ++t) {
        current_statement__ = 171;
        stan::model::assign(I_D_rev,
          stan::model::rvalue(I_D, "I_D",
            stan::model::index_uni(((n_obs - t) + 1))),
          "assigning variable I_D_rev", stan::model::index_uni(t));
      }
      current_statement__ = 173;
      stan::model::assign(x_i, A, "assigning variable x_i",
        stan::model::index_uni(1));
      current_statement__ = 174;
      stan::model::assign(x_i, n_obs, "assigning variable x_i",
        stan::model::index_uni(2));
      current_statement__ = 175;
      stan::model::assign(x_i, n_difeq, "assigning variable x_i",
        stan::model::index_uni(3));
      current_statement__ = 176;
      stan::model::assign(x_r, left_t, "assigning variable x_r",
        stan::model::index_min_max(1, n_obs));
      current_statement__ = 177;
      stan::model::assign(x_r, right_t, "assigning variable x_r",
        stan::model::index_min_max((n_obs + 1), (2 * n_obs)));
      current_statement__ = 178;
      stan::model::assign(x_r, age_dist, "assigning variable x_r",
        stan::model::index_min_max(((2 * n_obs) + 1), ((2 * n_obs) + A)));
      current_statement__ = 179;
      tau = (2.0 / incubation_period);
      current_statement__ = 180;
      gamma = (2.0 / infectious_period);
      current_statement__ = 159;
      stan::math::check_greater_or_equal(function__, "I_D_rev", I_D_rev, 0);
      current_statement__ = 163;
      stan::math::check_greater_or_equal(function__, "gamma", gamma, 0);
      current_statement__ = 164;
      stan::math::check_greater_or_equal(function__, "tau", tau, 0);
      current_statement__ = 181;
      stan::math::validate_non_negative_index("x_init", "A", A);
      current_statement__ = 182;
      x_noise_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 182;
      x_noise_1dim__ = ((n_changes - 1) * A);
      current_statement__ = 182;
      stan::math::validate_non_negative_index("x_noise",
        "(n_changes - 1) * A", x_noise_1dim__);
      current_statement__ = 183;
      stan::math::validate_non_negative_index("volatilities", "A", A);
      current_statement__ = 184;
      stan::math::validate_non_negative_index("L_raw", "L_raw_length",
        L_raw_length);
      current_statement__ = 185;
      stan::math::validate_non_negative_index("x_trajectory", "n_changes",
        n_changes);
      current_statement__ = 186;
      stan::math::validate_non_negative_index("x_trajectory", "A", A);
      current_statement__ = 187;
      stan::math::validate_non_negative_index("beta_trajectory", "n_obs",
        n_obs);
      current_statement__ = 188;
      stan::math::validate_non_negative_index("beta_trajectory", "A", A);
      current_statement__ = 189;
      beta_N_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 189;
      beta_N_1dim__ = (n_obs * A);
      current_statement__ = 189;
      stan::math::validate_non_negative_index("beta_N", "n_obs * A",
        beta_N_1dim__);
      current_statement__ = 190;
      theta_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 190;
      theta_1dim__ = (((A * A) + (A * n_obs)) + 4);
      current_statement__ = 190;
      stan::math::validate_non_negative_index("theta",
        "A * A + A * n_obs + 4", theta_1dim__);
      current_statement__ = 191;
      stan::math::validate_non_negative_index("state_solutions", "n_obs",
        n_obs);
      current_statement__ = 192;
      state_solutions_2dim__ = std::numeric_limits<int>::min();
      current_statement__ = 192;
      state_solutions_2dim__ = (A * n_difeq);
      current_statement__ = 192;
      stan::math::validate_non_negative_index("state_solutions",
        "A * n_difeq", state_solutions_2dim__);
      current_statement__ = 193;
      stan::math::validate_non_negative_index("comp_C", "n_obs", n_obs);
      current_statement__ = 194;
      stan::math::validate_non_negative_index("comp_C", "A", A);
      current_statement__ = 195;
      stan::math::validate_non_negative_index("E_casesByAge", "n_obs", n_obs);
      current_statement__ = 196;
      stan::math::validate_non_negative_index("E_casesByAge", "A", A);
      current_statement__ = 197;
      stan::math::validate_non_negative_index("E_deathsByAge", "n_obs", n_obs);
      current_statement__ = 198;
      stan::math::validate_non_negative_index("E_deathsByAge", "A", A);
      current_statement__ = 199;
      stan::math::validate_non_negative_index("cm_sym", "A", A);
      current_statement__ = 200;
      stan::math::validate_non_negative_index("cm_sym", "A", A);
      current_statement__ = 201;
      stan::math::validate_non_negative_index("cm_sample", "A", A);
      current_statement__ = 202;
      stan::math::validate_non_negative_index("cm_sample", "A", A);
      current_statement__ = 203;
      stan::math::validate_non_negative_index("L_raw_mat", "A", A);
      current_statement__ = 204;
      stan::math::validate_non_negative_index("L_raw_mat", "A", A);
      current_statement__ = 205;
      stan::math::validate_non_negative_index("L", "A", A);
      current_statement__ = 206;
      stan::math::validate_non_negative_index("L", "A", A);
      current_statement__ = 207;
      x_noise_mat_1dim__ = std::numeric_limits<int>::min();
      current_statement__ = 207;
      x_noise_mat_1dim__ = (n_changes - 1);
      current_statement__ = 207;
      stan::math::validate_non_negative_index("x_noise_mat", "n_changes - 1",
        x_noise_mat_1dim__);
      current_statement__ = 208;
      stan::math::validate_non_negative_index("x_noise_mat", "A", A);
      current_statement__ = 209;
      stan::math::validate_non_negative_index("E_cases", "n_obs", n_obs);
      current_statement__ = 210;
      stan::math::validate_non_negative_index("E_deaths", "n_obs", n_obs);
      current_statement__ = 211;
      stan::math::validate_non_negative_index("Susceptibles", "n_obs", n_obs);
      current_statement__ = 212;
      stan::math::validate_non_negative_index("Susceptibles", "A", A);
      current_statement__ = 213;
      stan::math::validate_non_negative_index("log_like_age", "n_obs", n_obs);
      current_statement__ = 214;
      stan::math::validate_non_negative_index("log_like_age", "A", A);
      current_statement__ = 215;
      stan::math::validate_non_negative_index("log_lik", "n_obs", n_obs);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    num_params_r__ = 1 + A + x_noise_1dim__ + 1 + A + 1 + L_raw_length;
  }
  inline std::string model_name() const final {
    return "model_igbm";
  }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.32.2",
             "stancflags = --allow-undefined"};
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI,
            stan::require_vector_like_t<VecR>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR>
  log_prob_impl(VecR& params_r__, VecI& params_i__, std::ostream*
                pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    static constexpr const char* function__ =
      "model_igbm_namespace::log_prob";
    // suppress unused var warning
    (void) function__;
    try {
      local_scalar_t__ x0 = DUMMY_VAR__;
      current_statement__ = 1;
      x0 = in__.template read<local_scalar_t__>();
      std::vector<local_scalar_t__> x_init =
        std::vector<local_scalar_t__>(A, DUMMY_VAR__);
      current_statement__ = 2;
      x_init = in__.template read<std::vector<local_scalar_t__>>(A);
      std::vector<local_scalar_t__> x_noise =
        std::vector<local_scalar_t__>(x_noise_1dim__, DUMMY_VAR__);
      current_statement__ = 3;
      x_noise = in__.template read<
                  std::vector<local_scalar_t__>>(x_noise_1dim__);
      local_scalar_t__ pi = DUMMY_VAR__;
      current_statement__ = 4;
      pi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(0,
             1, lp__);
      std::vector<local_scalar_t__> volatilities =
        std::vector<local_scalar_t__>(A, DUMMY_VAR__);
      current_statement__ = 5;
      volatilities = in__.template read_constrain_lb<
                       std::vector<local_scalar_t__>, jacobian__>(0, lp__, A);
      local_scalar_t__ phiD = DUMMY_VAR__;
      current_statement__ = 6;
      phiD = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      Eigen::Matrix<local_scalar_t__,-1,1> L_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(L_raw_length,
          DUMMY_VAR__);
      current_statement__ = 7;
      L_raw = in__.template read<
                Eigen::Matrix<local_scalar_t__,-1,1>>(L_raw_length);
      Eigen::Matrix<local_scalar_t__,-1,-1> x_trajectory =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n_changes, A,
          DUMMY_VAR__);
      local_scalar_t__ beta0 = DUMMY_VAR__;
      Eigen::Matrix<local_scalar_t__,-1,-1> beta_trajectory =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n_obs, A,
          DUMMY_VAR__);
      std::vector<local_scalar_t__> beta_N =
        std::vector<local_scalar_t__>(beta_N_1dim__, DUMMY_VAR__);
      std::vector<local_scalar_t__> theta =
        std::vector<local_scalar_t__>(theta_1dim__, DUMMY_VAR__);
      std::vector<std::vector<local_scalar_t__>> state_solutions =
        std::vector<std::vector<local_scalar_t__>>(n_obs,
          std::vector<local_scalar_t__>(state_solutions_2dim__, DUMMY_VAR__));
      Eigen::Matrix<local_scalar_t__,-1,-1> comp_C =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n_obs, A,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> E_casesByAge =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n_obs, A,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> E_deathsByAge =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(n_obs, A,
          DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> cm_sym =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(A, A, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> cm_sample =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(A, A, DUMMY_VAR__);
      Eigen::Matrix<local_scalar_t__,-1,-1> L_raw_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(A, A, DUMMY_VAR__);
      current_statement__ = 19;
      stan::model::assign(L_raw_mat, to_triangular(L_raw, A, pstream__),
        "assigning variable L_raw_mat");
      Eigen::Matrix<local_scalar_t__,-1,-1> L =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(A, A, DUMMY_VAR__);
      current_statement__ = 20;
      stan::model::assign(L, to_triangular(L_vector, A, pstream__),
        "assigning variable L");
      Eigen::Matrix<local_scalar_t__,-1,-1> x_noise_mat =
        Eigen::Matrix<local_scalar_t__,-1,-1>::Constant(x_noise_mat_1dim__,
          A, DUMMY_VAR__);
      current_statement__ = 21;
      stan::model::assign(x_noise_mat,
        stan::math::to_matrix(x_noise, (n_changes - 1), A),
        "assigning variable x_noise_mat");
      current_statement__ = 30;
      for (int col = 1; col <= A; ++col) {
        current_statement__ = 29;
        for (int row = col; row <= A; ++row) {
          current_statement__ = 28;
          stan::model::assign(L,
            (stan::model::rvalue(L_cm, "L_cm", stan::model::index_uni(row),
               stan::model::index_uni(col)) + ((prior_scale_contactmatrix *
            stan::model::rvalue(L_cm, "L_cm", stan::model::index_uni(row),
              stan::model::index_uni(col))) *
            stan::model::rvalue(L_raw_mat, "L_raw_mat",
              stan::model::index_uni(row), stan::model::index_uni(col)))),
            "assigning variable L", stan::model::index_uni(row),
            stan::model::index_uni(col));
        }
      }
      current_statement__ = 31;
      stan::model::assign(cm_sym, stan::math::tcrossprod(L),
        "assigning variable cm_sym");
      current_statement__ = 32;
      stan::model::assign(cm_sample,
        stan::math::diag_pre_multiply(pop_diag, cm_sym),
        "assigning variable cm_sample");
      current_statement__ = 33;
      stan::model::assign(x_trajectory, stan::math::to_row_vector(x_init),
        "assigning variable x_trajectory", stan::model::index_uni(1),
        stan::model::index_omni());
      current_statement__ = 36;
      for (int t = 2; t <= n_changes; ++t) {
        current_statement__ = 35;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 34;
          stan::model::assign(x_trajectory,
            (stan::model::rvalue(x_trajectory, "x_trajectory",
               stan::model::index_uni((t - 1)), stan::model::index_uni(j)) +
            (stan::model::rvalue(volatilities, "volatilities",
               stan::model::index_uni(j)) *
            stan::model::rvalue(x_noise_mat, "x_noise_mat",
              stan::model::index_uni((t - 1)), stan::model::index_uni(j)))),
            "assigning variable x_trajectory", stan::model::index_uni(t),
            stan::model::index_uni(j));
        }
      }
      current_statement__ = 37;
      beta0 = stan::math::exp(x0);
      current_statement__ = 42;
      if (stan::math::logical_eq(ecr_changes, 1)) {
        current_statement__ = 40;
        stan::model::assign(beta_trajectory, stan::math::exp(x_trajectory),
          "assigning variable beta_trajectory");
      } else {
        current_statement__ = 38;
        stan::model::assign(beta_trajectory,
          stan::math::append_row(
            repeat_matrix(
              stan::math::exp(
                stan::model::rvalue(x_trajectory, "x_trajectory",
                  stan::model::index_min_max(1, (n_changes - 1)),
                  stan::model::index_omni())), ecr_changes, pstream__),
            repeat_rv_to_matrix(
              stan::math::exp(
                stan::model::rvalue(x_trajectory, "x_trajectory",
                  stan::model::index_uni(n_changes),
                  stan::model::index_omni())), n_remainder, pstream__)),
          "assigning variable beta_trajectory");
      }
      current_statement__ = 43;
      stan::model::assign(beta_N,
        to_vector_colwise(beta_trajectory, pstream__),
        "assigning variable beta_N");
      current_statement__ = 44;
      stan::model::assign(theta, to_vector_rowwise(cm_sample, pstream__),
        "assigning variable theta", stan::model::index_min_max(1, (A * A)));
      current_statement__ = 45;
      stan::model::assign(theta, gamma, "assigning variable theta",
        stan::model::index_uni(((A * A) + 1)));
      current_statement__ = 46;
      stan::model::assign(theta, beta0, "assigning variable theta",
        stan::model::index_uni(((A * A) + 2)));
      current_statement__ = 47;
      stan::model::assign(theta, beta_N, "assigning variable theta",
        stan::model::index_min_max(((A * A) + 3), (((A * A) + (A * n_obs)) +
          2)));
      current_statement__ = 48;
      stan::model::assign(theta, pi, "assigning variable theta",
        stan::model::index_uni((((A * n_obs) + (A * A)) + 3)));
      current_statement__ = 49;
      stan::model::assign(theta, tau, "assigning variable theta",
        stan::model::index_uni((((A * n_obs) + (A * A)) + 4)));
      current_statement__ = 50;
      stan::model::assign(state_solutions,
        integrate_ode_trapezoidal(init, t0, ts, theta, x_r, x_i, pstream__),
        "assigning variable state_solutions");
      current_statement__ = 60;
      for (int t = 1; t <= n_obs; ++t) {
        current_statement__ = 52;
        if (stan::math::logical_eq(t, 1)) {
          current_statement__ = 51;
          stan::model::assign(E_deathsByAge, E_deathsByAge_day1,
            "assigning variable E_deathsByAge", stan::model::index_uni(t),
            stan::model::index_omni());
        }
        current_statement__ = 58;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 53;
          stan::model::assign(comp_C,
            (stan::model::rvalue(state_solutions, "state_solutions",
               stan::model::index_uni(t),
               stan::model::index_uni((((n_difeq - 1) * A) + j))) * n_pop),
            "assigning variable comp_C", stan::model::index_uni(t),
            stan::model::index_uni(j));
          current_statement__ = 54;
          stan::model::assign(E_casesByAge,
            (stan::model::rvalue(comp_C, "comp_C", stan::model::index_uni(t),
               stan::model::index_uni(j)) -
            (stan::math::logical_eq(t, 1) ? 0 : (stan::math::logical_gt(
                                                   stan::model::rvalue(
                                                     comp_C, "comp_C",
                                                     stan::model::index_uni(t),
                                                     stan::model::index_uni(j)),
                                                   stan::model::rvalue(
                                                     comp_C, "comp_C",
                                                     stan::model::index_uni(
                                                       (t - 1)),
                                                     stan::model::index_uni(j))) ? 
            stan::model::rvalue(comp_C, "comp_C",
              stan::model::index_uni((t - 1)), stan::model::index_uni(j)) : 0))),
            "assigning variable E_casesByAge", stan::model::index_uni(t),
            stan::model::index_uni(j));
          current_statement__ = 56;
          if (stan::math::logical_neq(t, 1)) {
            current_statement__ = 55;
            stan::model::assign(E_deathsByAge,
              (stan::model::rvalue(age_specific_ifr, "age_specific_ifr",
                 stan::model::index_uni(t), stan::model::index_uni(j)) *
              stan::math::dot_product(
                stan::math::head(
                  stan::model::rvalue(E_casesByAge, "E_casesByAge",
                    stan::model::index_omni(), stan::model::index_uni(j)), (t
                  - 1)), stan::math::tail(I_D_rev, (t - 1)))),
              "assigning variable E_deathsByAge", stan::model::index_uni(t),
              stan::model::index_uni(j));
          }
        }
      }
      current_statement__ = 9;
      stan::math::check_greater_or_equal(function__, "beta0", beta0, 0);
      current_statement__ = 10;
      stan::math::check_greater_or_equal(function__, "beta_trajectory",
        beta_trajectory, 0);
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "beta_N", beta_N, 0);
      current_statement__ = 15;
      stan::math::check_greater_or_equal(function__, "E_casesByAge",
        E_casesByAge, 0);
      current_statement__ = 16;
      stan::math::check_greater_or_equal(function__, "E_deathsByAge",
        E_deathsByAge, 0);
      {
        current_statement__ = 74;
        lp_accum__.add(stan::math::beta_lpdf<propto__>(pi,
                         stan::model::rvalue(prior_dist_pi, "prior_dist_pi",
                           stan::model::index_uni(1),
                           stan::model::index_uni(1)),
                         stan::model::rvalue(prior_dist_pi, "prior_dist_pi",
                           stan::model::index_uni(1),
                           stan::model::index_uni(2))));
        current_statement__ = 75;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x0, 0,
                         prior_scale_x0));
        current_statement__ = 76;
        lp_accum__.add(stan::math::normal_lpdf<propto__>(x_init, 0,
                         prior_scale_x1));
        current_statement__ = 77;
        lp_accum__.add(stan::math::std_normal_lpdf<propto__>(x_noise));
        current_statement__ = 78;
        lp_accum__.add(stan::math::std_normal_lpdf<propto__>(L_raw));
        current_statement__ = 88;
        if (stan::math::logical_eq(prior_dist_volatility, 1)) {
          current_statement__ = 87;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(volatilities,
                           prior_mean_volatility, prior_scale_volatility));
        } else {
          current_statement__ = 86;
          if (stan::math::logical_eq(prior_dist_volatility, 2)) {
            current_statement__ = 85;
            lp_accum__.add(stan::math::cauchy_lpdf<propto__>(volatilities,
                             prior_mean_volatility, prior_scale_volatility));
          } else {
            current_statement__ = 84;
            if (stan::math::logical_eq(prior_dist_volatility, 3)) {
              current_statement__ = 83;
              lp_accum__.add(stan::math::student_t_lpdf<propto__>(
                               volatilities, prior_df_volatility,
                               prior_mean_volatility, prior_scale_volatility));
            } else {
              current_statement__ = 82;
              if (stan::math::logical_eq(prior_dist_volatility, 4)) {
                current_statement__ = 81;
                lp_accum__.add(stan::math::gamma_lpdf<propto__>(volatilities,
                                 prior_shape_volatility,
                                 prior_rate_volatility));
              } else {
                current_statement__ = 80;
                if (stan::math::logical_eq(prior_dist_volatility, 5)) {
                  current_statement__ = 79;
                  lp_accum__.add(stan::math::exponential_lpdf<propto__>(
                                   volatilities, prior_rate_volatility));
                }
              }
            }
          }
        }
        current_statement__ = 98;
        if (stan::math::logical_eq(prior_dist_nb_dispersion, 1)) {
          current_statement__ = 97;
          lp_accum__.add(stan::math::normal_lpdf<propto__>(phiD,
                           prior_mean_nb_dispersion,
                           prior_scale_nb_dispersion));
        } else {
          current_statement__ = 96;
          if (stan::math::logical_eq(prior_dist_nb_dispersion, 2)) {
            current_statement__ = 95;
            lp_accum__.add(stan::math::cauchy_lpdf<propto__>(phiD,
                             prior_mean_nb_dispersion,
                             prior_scale_nb_dispersion));
          } else {
            current_statement__ = 94;
            if (stan::math::logical_eq(prior_dist_nb_dispersion, 3)) {
              current_statement__ = 93;
              lp_accum__.add(stan::math::student_t_lpdf<propto__>(phiD,
                               prior_df_nb_dispersion,
                               prior_mean_nb_dispersion,
                               prior_scale_nb_dispersion));
            } else {
              current_statement__ = 92;
              if (stan::math::logical_eq(prior_dist_nb_dispersion, 4)) {
                current_statement__ = 91;
                lp_accum__.add(stan::math::gamma_lpdf<propto__>(phiD,
                                 prior_shape_nb_dispersion,
                                 prior_rate_nb_dispersion));
              } else {
                current_statement__ = 90;
                if (stan::math::logical_eq(prior_dist_nb_dispersion, 5)) {
                  current_statement__ = 89;
                  lp_accum__.add(stan::math::exponential_lpdf<propto__>(phiD,
                                   prior_rate_nb_dispersion));
                }
              }
            }
          }
        }
        current_statement__ = 106;
        for (int i = 1; i <= n_obs; ++i) {
          current_statement__ = 104;
          for (int j = 1; j <= A; ++j) {
            current_statement__ = 102;
            if (stan::math::logical_eq(likelihood_variance_type, 0)) {
              current_statement__ = 101;
              lp_accum__.add(stan::math::neg_binomial_2_lpmf<false>(
                               stan::model::rvalue(y_data, "y_data",
                                 stan::model::index_uni(i),
                                 stan::model::index_uni(j)),
                               stan::model::rvalue(E_deathsByAge,
                                 "E_deathsByAge", stan::model::index_uni(i),
                                 stan::model::index_uni(j)), phiD));
            } else {
              current_statement__ = 100;
              if (stan::math::logical_eq(likelihood_variance_type, 1)) {
                current_statement__ = 99;
                lp_accum__.add(stan::math::neg_binomial_2_lpmf<false>(
                                 stan::model::rvalue(y_data, "y_data",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(j)),
                                 stan::model::rvalue(E_deathsByAge,
                                   "E_deathsByAge",
                                   stan::model::index_uni(i),
                                   stan::model::index_uni(j)),
                                 (stan::model::rvalue(E_deathsByAge,
                                    "E_deathsByAge",
                                    stan::model::index_uni(i),
                                    stan::model::index_uni(j)) / phiD)));
              }
            }
          }
        }
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
  }
  template <typename RNG, typename VecR, typename VecI, typename VecVar,
            stan::require_vector_like_vt<std::is_floating_point,
            VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral,
            VecI>* = nullptr, stan::require_vector_vt<std::is_floating_point,
            VecVar>* = nullptr>
  inline void
  write_array_impl(RNG& base_rng__, VecR& params_r__, VecI& params_i__,
                   VecVar& vars__, const bool
                   emit_transformed_parameters__ = true, const bool
                   emit_generated_quantities__ = true, std::ostream*
                   pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    static constexpr bool propto__ = true;
    // suppress unused var warning
    (void) propto__;
    double lp__ = 0.0;
    // suppress unused var warning
    (void) lp__;
    int current_statement__ = 0;
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    constexpr bool jacobian__ = false;
    static constexpr const char* function__ =
      "model_igbm_namespace::write_array";
    // suppress unused var warning
    (void) function__;
    try {
      double x0 = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 1;
      x0 = in__.template read<local_scalar_t__>();
      std::vector<double> x_init =
        std::vector<double>(A, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 2;
      x_init = in__.template read<std::vector<local_scalar_t__>>(A);
      std::vector<double> x_noise =
        std::vector<double>(x_noise_1dim__,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 3;
      x_noise = in__.template read<
                  std::vector<local_scalar_t__>>(x_noise_1dim__);
      double pi = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 4;
      pi = in__.template read_constrain_lub<local_scalar_t__, jacobian__>(0,
             1, lp__);
      std::vector<double> volatilities =
        std::vector<double>(A, std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 5;
      volatilities = in__.template read_constrain_lb<
                       std::vector<local_scalar_t__>, jacobian__>(0, lp__, A);
      double phiD = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 6;
      phiD = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(0,
               lp__);
      Eigen::Matrix<double,-1,1> L_raw =
        Eigen::Matrix<double,-1,1>::Constant(L_raw_length,
          std::numeric_limits<double>::quiet_NaN());
      current_statement__ = 7;
      L_raw = in__.template read<
                Eigen::Matrix<local_scalar_t__,-1,1>>(L_raw_length);
      Eigen::Matrix<double,-1,-1> x_trajectory =
        Eigen::Matrix<double,-1,-1>::Constant(n_changes, A,
          std::numeric_limits<double>::quiet_NaN());
      double beta0 = std::numeric_limits<double>::quiet_NaN();
      Eigen::Matrix<double,-1,-1> beta_trajectory =
        Eigen::Matrix<double,-1,-1>::Constant(n_obs, A,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<double> beta_N =
        std::vector<double>(beta_N_1dim__,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<double> theta =
        std::vector<double>(theta_1dim__,
          std::numeric_limits<double>::quiet_NaN());
      std::vector<std::vector<double>> state_solutions =
        std::vector<std::vector<double>>(n_obs,
          std::vector<double>(state_solutions_2dim__,
            std::numeric_limits<double>::quiet_NaN()));
      Eigen::Matrix<double,-1,-1> comp_C =
        Eigen::Matrix<double,-1,-1>::Constant(n_obs, A,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> E_casesByAge =
        Eigen::Matrix<double,-1,-1>::Constant(n_obs, A,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> E_deathsByAge =
        Eigen::Matrix<double,-1,-1>::Constant(n_obs, A,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> cm_sym =
        Eigen::Matrix<double,-1,-1>::Constant(A, A,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> cm_sample =
        Eigen::Matrix<double,-1,-1>::Constant(A, A,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> L_raw_mat =
        Eigen::Matrix<double,-1,-1>::Constant(A, A,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> L =
        Eigen::Matrix<double,-1,-1>::Constant(A, A,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> x_noise_mat =
        Eigen::Matrix<double,-1,-1>::Constant(x_noise_mat_1dim__, A,
          std::numeric_limits<double>::quiet_NaN());
      out__.write(x0);
      out__.write(x_init);
      out__.write(x_noise);
      out__.write(pi);
      out__.write(volatilities);
      out__.write(phiD);
      out__.write(L_raw);
      if (stan::math::logical_negation(
            (stan::math::primitive_value(emit_transformed_parameters__) ||
            stan::math::primitive_value(emit_generated_quantities__)))) {
        return ;
      }
      current_statement__ = 19;
      stan::model::assign(L_raw_mat, to_triangular(L_raw, A, pstream__),
        "assigning variable L_raw_mat");
      current_statement__ = 20;
      stan::model::assign(L, to_triangular(L_vector, A, pstream__),
        "assigning variable L");
      current_statement__ = 21;
      stan::model::assign(x_noise_mat,
        stan::math::to_matrix(x_noise, (n_changes - 1), A),
        "assigning variable x_noise_mat");
      current_statement__ = 30;
      for (int col = 1; col <= A; ++col) {
        current_statement__ = 29;
        for (int row = col; row <= A; ++row) {
          current_statement__ = 28;
          stan::model::assign(L,
            (stan::model::rvalue(L_cm, "L_cm", stan::model::index_uni(row),
               stan::model::index_uni(col)) + ((prior_scale_contactmatrix *
            stan::model::rvalue(L_cm, "L_cm", stan::model::index_uni(row),
              stan::model::index_uni(col))) *
            stan::model::rvalue(L_raw_mat, "L_raw_mat",
              stan::model::index_uni(row), stan::model::index_uni(col)))),
            "assigning variable L", stan::model::index_uni(row),
            stan::model::index_uni(col));
        }
      }
      current_statement__ = 31;
      stan::model::assign(cm_sym, stan::math::tcrossprod(L),
        "assigning variable cm_sym");
      current_statement__ = 32;
      stan::model::assign(cm_sample,
        stan::math::diag_pre_multiply(pop_diag, cm_sym),
        "assigning variable cm_sample");
      current_statement__ = 33;
      stan::model::assign(x_trajectory, stan::math::to_row_vector(x_init),
        "assigning variable x_trajectory", stan::model::index_uni(1),
        stan::model::index_omni());
      current_statement__ = 36;
      for (int t = 2; t <= n_changes; ++t) {
        current_statement__ = 35;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 34;
          stan::model::assign(x_trajectory,
            (stan::model::rvalue(x_trajectory, "x_trajectory",
               stan::model::index_uni((t - 1)), stan::model::index_uni(j)) +
            (stan::model::rvalue(volatilities, "volatilities",
               stan::model::index_uni(j)) *
            stan::model::rvalue(x_noise_mat, "x_noise_mat",
              stan::model::index_uni((t - 1)), stan::model::index_uni(j)))),
            "assigning variable x_trajectory", stan::model::index_uni(t),
            stan::model::index_uni(j));
        }
      }
      current_statement__ = 37;
      beta0 = stan::math::exp(x0);
      current_statement__ = 42;
      if (stan::math::logical_eq(ecr_changes, 1)) {
        current_statement__ = 40;
        stan::model::assign(beta_trajectory, stan::math::exp(x_trajectory),
          "assigning variable beta_trajectory");
      } else {
        current_statement__ = 38;
        stan::model::assign(beta_trajectory,
          stan::math::append_row(
            repeat_matrix(
              stan::math::exp(
                stan::model::rvalue(x_trajectory, "x_trajectory",
                  stan::model::index_min_max(1, (n_changes - 1)),
                  stan::model::index_omni())), ecr_changes, pstream__),
            repeat_rv_to_matrix(
              stan::math::exp(
                stan::model::rvalue(x_trajectory, "x_trajectory",
                  stan::model::index_uni(n_changes),
                  stan::model::index_omni())), n_remainder, pstream__)),
          "assigning variable beta_trajectory");
      }
      current_statement__ = 43;
      stan::model::assign(beta_N,
        to_vector_colwise(beta_trajectory, pstream__),
        "assigning variable beta_N");
      current_statement__ = 44;
      stan::model::assign(theta, to_vector_rowwise(cm_sample, pstream__),
        "assigning variable theta", stan::model::index_min_max(1, (A * A)));
      current_statement__ = 45;
      stan::model::assign(theta, gamma, "assigning variable theta",
        stan::model::index_uni(((A * A) + 1)));
      current_statement__ = 46;
      stan::model::assign(theta, beta0, "assigning variable theta",
        stan::model::index_uni(((A * A) + 2)));
      current_statement__ = 47;
      stan::model::assign(theta, beta_N, "assigning variable theta",
        stan::model::index_min_max(((A * A) + 3), (((A * A) + (A * n_obs)) +
          2)));
      current_statement__ = 48;
      stan::model::assign(theta, pi, "assigning variable theta",
        stan::model::index_uni((((A * n_obs) + (A * A)) + 3)));
      current_statement__ = 49;
      stan::model::assign(theta, tau, "assigning variable theta",
        stan::model::index_uni((((A * n_obs) + (A * A)) + 4)));
      current_statement__ = 50;
      stan::model::assign(state_solutions,
        integrate_ode_trapezoidal(init, t0, ts, theta, x_r, x_i, pstream__),
        "assigning variable state_solutions");
      current_statement__ = 60;
      for (int t = 1; t <= n_obs; ++t) {
        current_statement__ = 52;
        if (stan::math::logical_eq(t, 1)) {
          current_statement__ = 51;
          stan::model::assign(E_deathsByAge, E_deathsByAge_day1,
            "assigning variable E_deathsByAge", stan::model::index_uni(t),
            stan::model::index_omni());
        }
        current_statement__ = 58;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 53;
          stan::model::assign(comp_C,
            (stan::model::rvalue(state_solutions, "state_solutions",
               stan::model::index_uni(t),
               stan::model::index_uni((((n_difeq - 1) * A) + j))) * n_pop),
            "assigning variable comp_C", stan::model::index_uni(t),
            stan::model::index_uni(j));
          current_statement__ = 54;
          stan::model::assign(E_casesByAge,
            (stan::model::rvalue(comp_C, "comp_C", stan::model::index_uni(t),
               stan::model::index_uni(j)) -
            (stan::math::logical_eq(t, 1) ? 0 : (stan::math::logical_gt(
                                                   stan::model::rvalue(
                                                     comp_C, "comp_C",
                                                     stan::model::index_uni(t),
                                                     stan::model::index_uni(j)),
                                                   stan::model::rvalue(
                                                     comp_C, "comp_C",
                                                     stan::model::index_uni(
                                                       (t - 1)),
                                                     stan::model::index_uni(j))) ? 
            stan::model::rvalue(comp_C, "comp_C",
              stan::model::index_uni((t - 1)), stan::model::index_uni(j)) : 0))),
            "assigning variable E_casesByAge", stan::model::index_uni(t),
            stan::model::index_uni(j));
          current_statement__ = 56;
          if (stan::math::logical_neq(t, 1)) {
            current_statement__ = 55;
            stan::model::assign(E_deathsByAge,
              (stan::model::rvalue(age_specific_ifr, "age_specific_ifr",
                 stan::model::index_uni(t), stan::model::index_uni(j)) *
              stan::math::dot_product(
                stan::math::head(
                  stan::model::rvalue(E_casesByAge, "E_casesByAge",
                    stan::model::index_omni(), stan::model::index_uni(j)), (t
                  - 1)), stan::math::tail(I_D_rev, (t - 1)))),
              "assigning variable E_deathsByAge", stan::model::index_uni(t),
              stan::model::index_uni(j));
          }
        }
      }
      current_statement__ = 9;
      stan::math::check_greater_or_equal(function__, "beta0", beta0, 0);
      current_statement__ = 10;
      stan::math::check_greater_or_equal(function__, "beta_trajectory",
        beta_trajectory, 0);
      current_statement__ = 11;
      stan::math::check_greater_or_equal(function__, "beta_N", beta_N, 0);
      current_statement__ = 15;
      stan::math::check_greater_or_equal(function__, "E_casesByAge",
        E_casesByAge, 0);
      current_statement__ = 16;
      stan::math::check_greater_or_equal(function__, "E_deathsByAge",
        E_deathsByAge, 0);
      if (emit_transformed_parameters__) {
        out__.write(x_trajectory);
        out__.write(beta0);
        out__.write(beta_trajectory);
        out__.write(beta_N);
        out__.write(theta);
        for (int sym1__ = 1; sym1__ <= state_solutions_2dim__; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            out__.write(state_solutions[(sym2__ - 1)][(sym1__ - 1)]);
          }
        }
        out__.write(comp_C);
        out__.write(E_casesByAge);
        out__.write(E_deathsByAge);
        out__.write(cm_sym);
        out__.write(cm_sample);
        out__.write(L_raw_mat);
        out__.write(L);
        out__.write(x_noise_mat);
      }
      if (stan::math::logical_negation(emit_generated_quantities__)) {
        return ;
      }
      Eigen::Matrix<double,-1,1> E_cases =
        Eigen::Matrix<double,-1,1>::Constant(n_obs,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> E_deaths =
        Eigen::Matrix<double,-1,1>::Constant(n_obs,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> Susceptibles =
        Eigen::Matrix<double,-1,-1>::Constant(n_obs, A,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,-1> log_like_age =
        Eigen::Matrix<double,-1,-1>::Constant(n_obs, A,
          std::numeric_limits<double>::quiet_NaN());
      Eigen::Matrix<double,-1,1> log_lik =
        Eigen::Matrix<double,-1,1>::Constant(n_obs,
          std::numeric_limits<double>::quiet_NaN());
      double deviance = std::numeric_limits<double>::quiet_NaN();
      current_statement__ = 61;
      stan::model::assign(E_cases,
        stan::math::multiply(E_casesByAge, ones_vector_A),
        "assigning variable E_cases");
      current_statement__ = 62;
      stan::model::assign(E_deaths,
        stan::math::multiply(E_deathsByAge, ones_vector_A),
        "assigning variable E_deaths");
      current_statement__ = 72;
      for (int t = 1; t <= n_obs; ++t) {
        current_statement__ = 69;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 63;
          stan::model::assign(Susceptibles,
            ((stan::model::rvalue(state_solutions, "state_solutions",
                stan::model::index_uni(t), stan::model::index_uni(j)) +
            (stan::model::rvalue(age_dist, "age_dist",
               stan::model::index_uni(j)) * (1 - pi))) * n_pop),
            "assigning variable Susceptibles", stan::model::index_uni(t),
            stan::model::index_uni(j));
          current_statement__ = 67;
          if (stan::math::logical_eq(likelihood_variance_type, 0)) {
            current_statement__ = 66;
            stan::model::assign(log_like_age,
              stan::math::neg_binomial_2_lpmf<false>(
                stan::model::rvalue(y_data, "y_data",
                  stan::model::index_uni(t), stan::model::index_uni(j)),
                stan::model::rvalue(E_deathsByAge, "E_deathsByAge",
                  stan::model::index_uni(t), stan::model::index_uni(j)), phiD),
              "assigning variable log_like_age", stan::model::index_uni(t),
              stan::model::index_uni(j));
          } else {
            current_statement__ = 65;
            if (stan::math::logical_eq(likelihood_variance_type, 1)) {
              current_statement__ = 64;
              stan::model::assign(log_like_age,
                stan::math::neg_binomial_2_lpmf<false>(
                  stan::model::rvalue(y_data, "y_data",
                    stan::model::index_uni(t), stan::model::index_uni(j)),
                  stan::model::rvalue(E_deathsByAge, "E_deathsByAge",
                    stan::model::index_uni(t), stan::model::index_uni(j)),
                  (stan::model::rvalue(E_deathsByAge, "E_deathsByAge",
                     stan::model::index_uni(t), stan::model::index_uni(j)) /
                  phiD)), "assigning variable log_like_age",
                stan::model::index_uni(t), stan::model::index_uni(j));
            }
          }
        }
        current_statement__ = 70;
        stan::model::assign(log_lik,
          stan::math::sum(
            stan::model::rvalue(log_like_age, "log_like_age",
              stan::model::index_uni(t), stan::model::index_omni())),
          "assigning variable log_lik", stan::model::index_uni(t));
      }
      current_statement__ = 73;
      deviance = (-2 * stan::math::sum(log_lik));
      out__.write(E_cases);
      out__.write(E_deaths);
      out__.write(Susceptibles);
      out__.write(log_like_age);
      out__.write(log_lik);
      out__.write(deviance);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, typename VecI,
            stan::require_vector_t<VecVar>* = nullptr,
            stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void
  unconstrain_array_impl(const VecVar& params_r__, const VecI& params_i__,
                         VecVar& vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ x0 = DUMMY_VAR__;
      current_statement__ = 1;
      x0 = in__.read<local_scalar_t__>();
      out__.write(x0);
      std::vector<local_scalar_t__> x_init =
        std::vector<local_scalar_t__>(A, DUMMY_VAR__);
      current_statement__ = 2;
      stan::model::assign(x_init,
        in__.read<std::vector<local_scalar_t__>>(A),
        "assigning variable x_init");
      out__.write(x_init);
      std::vector<local_scalar_t__> x_noise =
        std::vector<local_scalar_t__>(x_noise_1dim__, DUMMY_VAR__);
      current_statement__ = 3;
      stan::model::assign(x_noise,
        in__.read<std::vector<local_scalar_t__>>(x_noise_1dim__),
        "assigning variable x_noise");
      out__.write(x_noise);
      local_scalar_t__ pi = DUMMY_VAR__;
      current_statement__ = 4;
      pi = in__.read<local_scalar_t__>();
      out__.write_free_lub(0, 1, pi);
      std::vector<local_scalar_t__> volatilities =
        std::vector<local_scalar_t__>(A, DUMMY_VAR__);
      current_statement__ = 5;
      stan::model::assign(volatilities,
        in__.read<std::vector<local_scalar_t__>>(A),
        "assigning variable volatilities");
      out__.write_free_lb(0, volatilities);
      local_scalar_t__ phiD = DUMMY_VAR__;
      current_statement__ = 6;
      phiD = in__.read<local_scalar_t__>();
      out__.write_free_lb(0, phiD);
      Eigen::Matrix<local_scalar_t__,-1,1> L_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(L_raw_length,
          DUMMY_VAR__);
      current_statement__ = 7;
      stan::model::assign(L_raw,
        in__.read<Eigen::Matrix<local_scalar_t__,-1,1>>(L_raw_length),
        "assigning variable L_raw");
      out__.write(L_raw);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  template <typename VecVar, stan::require_vector_t<VecVar>* = nullptr>
  inline void
  transform_inits_impl(const stan::io::var_context& context__, VecVar&
                       vars__, std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    stan::io::serializer<local_scalar_t__> out__(vars__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    // suppress unused var warning
    (void) DUMMY_VAR__;
    try {
      current_statement__ = 1;
      context__.validate_dims("parameter initialization", "x0", "double",
        std::vector<size_t>{});
      current_statement__ = 2;
      context__.validate_dims("parameter initialization", "x_init", "double",
        std::vector<size_t>{static_cast<size_t>(A)});
      current_statement__ = 3;
      context__.validate_dims("parameter initialization", "x_noise",
        "double", std::vector<size_t>{static_cast<size_t>(x_noise_1dim__)});
      current_statement__ = 4;
      context__.validate_dims("parameter initialization", "pi", "double",
        std::vector<size_t>{});
      current_statement__ = 5;
      context__.validate_dims("parameter initialization", "volatilities",
        "double", std::vector<size_t>{static_cast<size_t>(A)});
      current_statement__ = 6;
      context__.validate_dims("parameter initialization", "phiD", "double",
        std::vector<size_t>{});
      current_statement__ = 7;
      context__.validate_dims("parameter initialization", "L_raw", "double",
        std::vector<size_t>{static_cast<size_t>(L_raw_length)});
      int pos__ = std::numeric_limits<int>::min();
      pos__ = 1;
      local_scalar_t__ x0 = DUMMY_VAR__;
      current_statement__ = 1;
      x0 = context__.vals_r("x0")[(1 - 1)];
      out__.write(x0);
      std::vector<local_scalar_t__> x_init =
        std::vector<local_scalar_t__>(A, DUMMY_VAR__);
      current_statement__ = 2;
      x_init = context__.vals_r("x_init");
      out__.write(x_init);
      std::vector<local_scalar_t__> x_noise =
        std::vector<local_scalar_t__>(x_noise_1dim__, DUMMY_VAR__);
      current_statement__ = 3;
      x_noise = context__.vals_r("x_noise");
      out__.write(x_noise);
      local_scalar_t__ pi = DUMMY_VAR__;
      current_statement__ = 4;
      pi = context__.vals_r("pi")[(1 - 1)];
      out__.write_free_lub(0, 1, pi);
      std::vector<local_scalar_t__> volatilities =
        std::vector<local_scalar_t__>(A, DUMMY_VAR__);
      current_statement__ = 5;
      volatilities = context__.vals_r("volatilities");
      out__.write_free_lb(0, volatilities);
      local_scalar_t__ phiD = DUMMY_VAR__;
      current_statement__ = 6;
      phiD = context__.vals_r("phiD")[(1 - 1)];
      out__.write_free_lb(0, phiD);
      Eigen::Matrix<local_scalar_t__,-1,1> L_raw =
        Eigen::Matrix<local_scalar_t__,-1,1>::Constant(L_raw_length,
          DUMMY_VAR__);
      {
        std::vector<local_scalar_t__> L_raw_flat__;
        current_statement__ = 7;
        L_raw_flat__ = context__.vals_r("L_raw");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= L_raw_length; ++sym1__) {
          current_statement__ = 7;
          stan::model::assign(L_raw, L_raw_flat__[(pos__ - 1)],
            "assigning variable L_raw", stan::model::index_uni(sym1__));
          current_statement__ = 7;
          pos__ = (pos__ + 1);
        }
      }
      out__.write(L_raw);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
    }
  }
  inline void
  get_param_names(std::vector<std::string>& names__, const bool
                  emit_transformed_parameters__ = true, const bool
                  emit_generated_quantities__ = true) const {
    names__ = std::vector<std::string>{"x0", "x_init", "x_noise", "pi",
                "volatilities", "phiD", "L_raw"};
    if (emit_transformed_parameters__) {
      std::vector<std::string>
        temp{"x_trajectory", "beta0", "beta_trajectory", "beta_N", "theta",
             "state_solutions", "comp_C", "E_casesByAge", "E_deathsByAge",
             "cm_sym", "cm_sample", "L_raw_mat", "L", "x_noise_mat"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::string>
        temp{"E_cases", "E_deaths", "Susceptibles", "log_like_age",
             "log_lik", "deviance"};
      names__.reserve(names__.size() + temp.size());
      names__.insert(names__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  get_dims(std::vector<std::vector<size_t>>& dimss__, const bool
           emit_transformed_parameters__ = true, const bool
           emit_generated_quantities__ = true) const {
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(A)},
                std::vector<size_t>{static_cast<size_t>(x_noise_1dim__)},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(A)},
                std::vector<size_t>{},
                std::vector<size_t>{static_cast<size_t>(L_raw_length)}};
    if (emit_transformed_parameters__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(n_changes),
               static_cast<size_t>(A)}, std::vector<size_t>{},
             std::vector<size_t>{static_cast<size_t>(n_obs),
               static_cast<size_t>(A)},
             std::vector<size_t>{static_cast<size_t>(beta_N_1dim__)},
             std::vector<size_t>{static_cast<size_t>(theta_1dim__)},
             std::vector<size_t>{static_cast<size_t>(n_obs),
               static_cast<size_t>(state_solutions_2dim__)},
             std::vector<size_t>{static_cast<size_t>(n_obs),
               static_cast<size_t>(A)},
             std::vector<size_t>{static_cast<size_t>(n_obs),
               static_cast<size_t>(A)},
             std::vector<size_t>{static_cast<size_t>(n_obs),
               static_cast<size_t>(A)},
             std::vector<size_t>{static_cast<size_t>(A),
               static_cast<size_t>(A)},
             std::vector<size_t>{static_cast<size_t>(A),
               static_cast<size_t>(A)},
             std::vector<size_t>{static_cast<size_t>(A),
               static_cast<size_t>(A)},
             std::vector<size_t>{static_cast<size_t>(A),
               static_cast<size_t>(A)},
             std::vector<size_t>{static_cast<size_t>(x_noise_mat_1dim__),
               static_cast<size_t>(A)}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
    if (emit_generated_quantities__) {
      std::vector<std::vector<size_t>>
        temp{std::vector<size_t>{static_cast<size_t>(n_obs)},
             std::vector<size_t>{static_cast<size_t>(n_obs)},
             std::vector<size_t>{static_cast<size_t>(n_obs),
               static_cast<size_t>(A)},
             std::vector<size_t>{static_cast<size_t>(n_obs),
               static_cast<size_t>(A)},
             std::vector<size_t>{static_cast<size_t>(n_obs)},
             std::vector<size_t>{}};
      dimss__.reserve(dimss__.size() + temp.size());
      dimss__.insert(dimss__.end(), temp.begin(), temp.end());
    }
  }
  inline void
  constrained_param_names(std::vector<std::string>& param_names__, bool
                          emit_transformed_parameters__ = true, bool
                          emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "x0");
    for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
      param_names__.emplace_back(std::string() + "x_init" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= x_noise_1dim__; ++sym1__) {
      param_names__.emplace_back(std::string() + "x_noise" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "pi");
    for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
      param_names__.emplace_back(std::string() + "volatilities" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "phiD");
    for (int sym1__ = 1; sym1__ <= L_raw_length; ++sym1__) {
      param_names__.emplace_back(std::string() + "L_raw" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_changes; ++sym2__) {
          param_names__.emplace_back(std::string() + "x_trajectory" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      param_names__.emplace_back(std::string() + "beta0");
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "beta_trajectory" + '.'
            + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= beta_N_1dim__; ++sym1__) {
        param_names__.emplace_back(std::string() + "beta_N" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= theta_1dim__; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= state_solutions_2dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "state_solutions" + '.'
            + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "comp_C" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "E_casesByAge" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "E_deathsByAge" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          param_names__.emplace_back(std::string() + "cm_sym" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          param_names__.emplace_back(std::string() + "cm_sample" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          param_names__.emplace_back(std::string() + "L_raw_mat" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          param_names__.emplace_back(std::string() + "L" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= x_noise_mat_1dim__; ++sym2__) {
          param_names__.emplace_back(std::string() + "x_noise_mat" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        param_names__.emplace_back(std::string() + "E_cases" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        param_names__.emplace_back(std::string() + "E_deaths" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "Susceptibles" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "log_like_age" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        param_names__.emplace_back(std::string() + "log_lik" + '.' +
          std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "deviance");
    }
  }
  inline void
  unconstrained_param_names(std::vector<std::string>& param_names__, bool
                            emit_transformed_parameters__ = true, bool
                            emit_generated_quantities__ = true) const final {
    param_names__.emplace_back(std::string() + "x0");
    for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
      param_names__.emplace_back(std::string() + "x_init" + '.' +
        std::to_string(sym1__));
    }
    for (int sym1__ = 1; sym1__ <= x_noise_1dim__; ++sym1__) {
      param_names__.emplace_back(std::string() + "x_noise" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "pi");
    for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
      param_names__.emplace_back(std::string() + "volatilities" + '.' +
        std::to_string(sym1__));
    }
    param_names__.emplace_back(std::string() + "phiD");
    for (int sym1__ = 1; sym1__ <= L_raw_length; ++sym1__) {
      param_names__.emplace_back(std::string() + "L_raw" + '.' +
        std::to_string(sym1__));
    }
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_changes; ++sym2__) {
          param_names__.emplace_back(std::string() + "x_trajectory" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      param_names__.emplace_back(std::string() + "beta0");
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "beta_trajectory" + '.'
            + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= beta_N_1dim__; ++sym1__) {
        param_names__.emplace_back(std::string() + "beta_N" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= theta_1dim__; ++sym1__) {
        param_names__.emplace_back(std::string() + "theta" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= state_solutions_2dim__; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "state_solutions" + '.'
            + std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "comp_C" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "E_casesByAge" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "E_deathsByAge" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          param_names__.emplace_back(std::string() + "cm_sym" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          param_names__.emplace_back(std::string() + "cm_sample" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          param_names__.emplace_back(std::string() + "L_raw_mat" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          param_names__.emplace_back(std::string() + "L" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= x_noise_mat_1dim__; ++sym2__) {
          param_names__.emplace_back(std::string() + "x_noise_mat" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
    }
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        param_names__.emplace_back(std::string() + "E_cases" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        param_names__.emplace_back(std::string() + "E_deaths" + '.' +
          std::to_string(sym1__));
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "Susceptibles" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          param_names__.emplace_back(std::string() + "log_like_age" + '.' +
            std::to_string(sym2__) + '.' + std::to_string(sym1__));
        }
      }
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        param_names__.emplace_back(std::string() + "log_lik" + '.' +
          std::to_string(sym1__));
      }
      param_names__.emplace_back(std::string() + "deviance");
    }
  }
  inline std::string get_constrained_sizedtypes() const {
    return std::string("[{\"name\":\"x0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_init\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(A) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_noise\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(x_noise_1dim__) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"pi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"volatilities\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(A) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"phiD\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"L_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(L_raw_length) + "},\"block\":\"parameters\"},{\"name\":\"x_trajectory\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_changes) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"beta_trajectory\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta_N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(beta_N_1dim__) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(theta_1dim__) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"state_solutions\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_obs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(state_solutions_2dim__) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"comp_C\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"E_casesByAge\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"E_deathsByAge\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"cm_sym\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(A) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"cm_sample\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(A) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"L_raw_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(A) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"L\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(A) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"x_noise_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(x_noise_mat_1dim__) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"E_cases\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_obs) + "},\"block\":\"generated_quantities\"},{\"name\":\"E_deaths\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_obs) + "},\"block\":\"generated_quantities\"},{\"name\":\"Susceptibles\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"generated_quantities\"},{\"name\":\"log_like_age\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"generated_quantities\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_obs) + "},\"block\":\"generated_quantities\"},{\"name\":\"deviance\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  inline std::string get_unconstrained_sizedtypes() const {
    return std::string("[{\"name\":\"x0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_init\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(A) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_noise\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(x_noise_1dim__) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"pi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"volatilities\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(A) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"phiD\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"L_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(L_raw_length) + "},\"block\":\"parameters\"},{\"name\":\"x_trajectory\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_changes) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"beta_trajectory\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta_N\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(beta_N_1dim__) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(theta_1dim__) + ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"state_solutions\",\"type\":{\"name\":\"array\",\"length\":" + std::to_string(n_obs) + ",\"element_type\":{\"name\":\"array\",\"length\":" + std::to_string(state_solutions_2dim__) + ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"comp_C\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"E_casesByAge\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"E_deathsByAge\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"cm_sym\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(A) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"cm_sample\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(A) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"L_raw_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(A) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"L\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(A) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"x_noise_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(x_noise_mat_1dim__) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"transformed_parameters\"},{\"name\":\"E_cases\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_obs) + "},\"block\":\"generated_quantities\"},{\"name\":\"E_deaths\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_obs) + "},\"block\":\"generated_quantities\"},{\"name\":\"Susceptibles\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"generated_quantities\"},{\"name\":\"log_like_age\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(n_obs) + ",\"cols\":" + std::to_string(A) + "},\"block\":\"generated_quantities\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(n_obs) + "},\"block\":\"generated_quantities\"},{\"name\":\"deviance\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]");
  }
  // Begin method overload boilerplate
  template <typename RNG> inline void
  write_array(RNG& base_rng, Eigen::Matrix<double,-1,1>& params_r,
              Eigen::Matrix<double,-1,1>& vars, const bool
              emit_transformed_parameters = true, const bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((1 + A) + x_noise_1dim__) + 1) + A) + 1)
      + L_raw_length);
    const size_t num_transformed = emit_transformed_parameters *
      (((((((((((((((n_changes * A) + 1) + (n_obs * A)) + beta_N_1dim__) +
      theta_1dim__) + (n_obs * state_solutions_2dim__)) + (n_obs * A)) +
      (n_obs * A)) + (n_obs * A)) + (A * A)) + (A * A)) + (A * A)) + (A * A))
      + (x_noise_mat_1dim__ * A)));
    const size_t num_gen_quantities = emit_generated_quantities * ((((((n_obs
      + n_obs) + (n_obs * A)) + (n_obs * A)) + n_obs) + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    std::vector<int> params_i;
    vars = Eigen::Matrix<double,-1,1>::Constant(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <typename RNG> inline void
  write_array(RNG& base_rng, std::vector<double>& params_r, std::vector<int>&
              params_i, std::vector<double>& vars, bool
              emit_transformed_parameters = true, bool
              emit_generated_quantities = true, std::ostream*
              pstream = nullptr) const {
    const size_t num_params__ = ((((((1 + A) + x_noise_1dim__) + 1) + A) + 1)
      + L_raw_length);
    const size_t num_transformed = emit_transformed_parameters *
      (((((((((((((((n_changes * A) + 1) + (n_obs * A)) + beta_N_1dim__) +
      theta_1dim__) + (n_obs * state_solutions_2dim__)) + (n_obs * A)) +
      (n_obs * A)) + (n_obs * A)) + (A * A)) + (A * A)) + (A * A)) + (A * A))
      + (x_noise_mat_1dim__ * A)));
    const size_t num_gen_quantities = emit_generated_quantities * ((((((n_obs
      + n_obs) + (n_obs * A)) + (n_obs * A)) + n_obs) + 1));
    const size_t num_to_write = num_params__ + num_transformed +
      num_gen_quantities;
    vars = std::vector<double>(num_to_write,
             std::numeric_limits<double>::quiet_NaN());
    write_array_impl(base_rng, params_r, params_i, vars,
      emit_transformed_parameters, emit_generated_quantities, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(Eigen::Matrix<T_,-1,1>& params_r, std::ostream* pstream = nullptr) const {
    Eigen::Matrix<int,-1,1> params_i;
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  template <bool propto__, bool jacobian__, typename T_> inline T_
  log_prob(std::vector<T_>& params_r, std::vector<int>& params_i,
           std::ostream* pstream = nullptr) const {
    return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
  }
  inline void
  transform_inits(const stan::io::var_context& context,
                  Eigen::Matrix<double,-1,1>& params_r, std::ostream*
                  pstream = nullptr) const final {
    std::vector<double> params_r_vec(params_r.size());
    std::vector<int> params_i;
    transform_inits(context, params_i, params_r_vec, pstream);
    params_r = Eigen::Map<Eigen::Matrix<double,-1,1>>(params_r_vec.data(),
                 params_r_vec.size());
  }
  inline void
  transform_inits(const stan::io::var_context& context, std::vector<int>&
                  params_i, std::vector<double>& vars, std::ostream*
                  pstream__ = nullptr) const {
    vars.resize(num_params_r__);
    transform_inits_impl(context, vars, pstream__);
  }
  inline void
  unconstrain_array(const std::vector<double>& params_constrained,
                    std::vector<double>& params_unconstrained, std::ostream*
                    pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = std::vector<double>(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
  inline void
  unconstrain_array(const Eigen::Matrix<double,-1,1>& params_constrained,
                    Eigen::Matrix<double,-1,1>& params_unconstrained,
                    std::ostream* pstream = nullptr) const {
    const std::vector<int> params_i;
    params_unconstrained = Eigen::Matrix<double,-1,1>::Constant(num_params_r__,
                             std::numeric_limits<double>::quiet_NaN());
    unconstrain_array_impl(params_constrained, params_i,
      params_unconstrained, pstream);
  }
};
}
using stan_model = model_igbm_namespace::model_igbm;
#ifndef USING_R
// Boilerplate
stan::model::model_base&
new_model(stan::io::var_context& data_context, unsigned int seed,
          std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_igbm_namespace::profiles__;
}
#endif
#endif
