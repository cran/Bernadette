// Generated by rstantools.  Do not edit by hand.

#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#ifndef USE_STANC3
#define USE_STANC3
#endif
#include <rstan/rstaninc.hpp>
// Code generated by stanc v2.26.1-4-gd72b68b7-dirty
#include <stan/model/model_header.hpp>
namespace model_igbm_namespace {
inline void validate_positive_index(const char* var_name, const char* expr,
                                    int val) {
  if (val < 1) {
    std::stringstream msg;
    msg << "Found dimension size less than one in simplex declaration"
        << "; variable=" << var_name << "; dimension size expression=" << expr
        << "; expression value=" << val;
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
inline void validate_unit_vector_index(const char* var_name, const char* expr,
                                       int val) {
  if (val <= 1) {
    std::stringstream msg;
    if (val == 1) {
      msg << "Found dimension size one in unit vector declaration."
          << " One-dimensional unit vector is discrete"
          << " but the target distribution must be continuous."
          << " variable=" << var_name << "; dimension size expression=" << expr;
    } else {
      msg << "Found dimension size less than one in unit vector declaration"
          << "; variable=" << var_name << "; dimension size expression=" << expr
          << "; expression value=" << val;
    }
    std::string msg_str(msg.str());
    throw std::invalid_argument(msg_str.c_str());
  }
}
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math;
using stan::math::pow; 
stan::math::profile_map profiles__;
static int current_statement__= 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'string', line 271, column 0 to column 8)",
                                                      " (in 'string', line 272, column 0 to column 21)",
                                                      " (in 'string', line 273, column 0 to column 38)",
                                                      " (in 'string', line 274, column 0 to column 30)",
                                                      " (in 'string', line 275, column 0 to column 38)",
                                                      " (in 'string', line 276, column 0 to column 21)",
                                                      " (in 'string', line 277, column 0 to column 27)",
                                                      " (in 'string', line 280, column 0 to column 34)",
                                                      " (in 'string', line 281, column 0 to column 22)",
                                                      " (in 'string', line 282, column 0 to column 44)",
                                                      " (in 'string', line 283, column 0 to column 38)",
                                                      " (in 'string', line 284, column 0 to column 36)",
                                                      " (in 'string', line 285, column 0 to column 47)",
                                                      " (in 'string', line 286, column 0 to column 24)",
                                                      " (in 'string', line 287, column 0 to column 41)",
                                                      " (in 'string', line 288, column 0 to column 42)",
                                                      " (in 'string', line 289, column 0 to column 20)",
                                                      " (in 'string', line 290, column 0 to column 23)",
                                                      " (in 'string', line 292, column 0 to column 49)",
                                                      " (in 'string', line 293, column 0 to column 44)",
                                                      " (in 'string', line 294, column 0 to column 76)",
                                                      " (in 'string', line 295, column 34 to column 128)",
                                                      " (in 'string', line 295, column 16 to column 128)",
                                                      " (in 'string', line 295, column 0 to column 128)",
                                                      " (in 'string', line 296, column 0 to column 23)",
                                                      " (in 'string', line 297, column 0 to column 48)",
                                                      " (in 'string', line 299, column 0 to column 41)",
                                                      " (in 'string', line 300, column 38 to column 117)",
                                                      " (in 'string', line 300, column 23 to column 117)",
                                                      " (in 'string', line 300, column 0 to column 117)",
                                                      " (in 'string', line 301, column 0 to column 16)",
                                                      " (in 'string', line 305, column 1 to line 307, column 33)",
                                                      " (in 'string', line 304, column 7 to line 308, column 1)",
                                                      " (in 'string', line 303, column 2 to column 38)",
                                                      " (in 'string', line 302, column 22 to line 304, column 1)",
                                                      " (in 'string', line 302, column 0 to line 308, column 1)",
                                                      " (in 'string', line 309, column 0 to column 44)",
                                                      " (in 'string', line 311, column 0 to column 48)",
                                                      " (in 'string', line 312, column 0 to column 25)",
                                                      " (in 'string', line 313, column 0 to column 25)",
                                                      " (in 'string', line 314, column 0 to column 46)",
                                                      " (in 'string', line 315, column 0 to column 30)",
                                                      " (in 'string', line 316, column 0 to column 31)",
                                                      " (in 'string', line 318, column 0 to line 324, column 36)",
                                                      " (in 'string', line 327, column 12 to column 51)",
                                                      " (in 'string', line 327, column 1 to column 51)",
                                                      " (in 'string', line 330, column 2 to column 63)",
                                                      " (in 'string', line 332, column 2 to column 103)",
                                                      " (in 'string', line 334, column 13 to column 119)",
                                                      " (in 'string', line 334, column 2 to column 119)",
                                                      " (in 'string', line 328, column 15 to line 335, column 2)",
                                                      " (in 'string', line 328, column 1 to line 335, column 2)",
                                                      " (in 'string', line 326, column 19 to line 336, column 1)",
                                                      " (in 'string', line 326, column 0 to line 336, column 1)",
                                                      " (in 'string', line 364, column 0 to column 22)",
                                                      " (in 'string', line 365, column 0 to column 23)",
                                                      " (in 'string', line 366, column 0 to column 30)",
                                                      " (in 'string', line 368, column 0 to column 29)",
                                                      " (in 'string', line 369, column 0 to column 22)",
                                                      " (in 'string', line 370, column 0 to column 14)",
                                                      " (in 'string', line 372, column 0 to column 39)",
                                                      " (in 'string', line 374, column 0 to column 41)",
                                                      " (in 'string', line 378, column 2 to column 80)",
                                                      " (in 'string', line 380, column 42 to column 141)",
                                                      " (in 'string', line 380, column 7 to column 141)",
                                                      " (in 'string', line 379, column 37 to column 117)",
                                                      " (in 'string', line 379, column 2 to line 380, column 141)",
                                                      " (in 'string', line 377, column 16 to line 381, column 2)",
                                                      " (in 'string', line 377, column 1 to line 381, column 2)",
                                                      " (in 'string', line 382, column 1 to column 36)",
                                                      " (in 'string', line 376, column 19 to line 383, column 1)",
                                                      " (in 'string', line 376, column 0 to line 383, column 1)",
                                                      " (in 'string', line 385, column 0 to column 31)",
                                                      " (in 'string', line 340, column 0 to column 50)",
                                                      " (in 'string', line 341, column 0 to column 31)",
                                                      " (in 'string', line 342, column 0 to column 35)",
                                                      " (in 'string', line 343, column 0 to column 23)",
                                                      " (in 'string', line 344, column 0 to column 21)",
                                                      " (in 'string', line 349, column 37 to column 87)",
                                                      " (in 'string', line 349, column 5 to column 87)",
                                                      " (in 'string', line 348, column 37 to column 105)",
                                                      " (in 'string', line 348, column 5 to line 349, column 87)",
                                                      " (in 'string', line 347, column 37 to column 130)",
                                                      " (in 'string', line 347, column 5 to line 349, column 87)",
                                                      " (in 'string', line 346, column 37 to column 106)",
                                                      " (in 'string', line 346, column 5 to line 349, column 87)",
                                                      " (in 'string', line 345, column 32 to column 101)",
                                                      " (in 'string', line 345, column 0 to line 349, column 87)",
                                                      " (in 'string', line 354, column 40 to column 85)",
                                                      " (in 'string', line 354, column 5 to column 85)",
                                                      " (in 'string', line 353, column 40 to column 106)",
                                                      " (in 'string', line 353, column 5 to line 354, column 85)",
                                                      " (in 'string', line 352, column 40 to column 134)",
                                                      " (in 'string', line 352, column 5 to line 354, column 85)",
                                                      " (in 'string', line 351, column 40 to column 107)",
                                                      " (in 'string', line 351, column 5 to line 354, column 85)",
                                                      " (in 'string', line 350, column 35 to column 102)",
                                                      " (in 'string', line 350, column 0 to line 354, column 85)",
                                                      " (in 'string', line 359, column 43 to column 133)",
                                                      " (in 'string', line 359, column 8 to column 133)",
                                                      " (in 'string', line 358, column 38 to column 109)",
                                                      " (in 'string', line 358, column 3 to line 359, column 133)",
                                                      " (in 'string', line 357, column 17 to line 360, column 3)",
                                                      " (in 'string', line 357, column 2 to line 360, column 3)",
                                                      " (in 'string', line 356, column 19 to line 361, column 2)",
                                                      " (in 'string', line 356, column 1 to line 361, column 2)",
                                                      " (in 'string', line 171, column 0 to column 6)",
                                                      " (in 'string', line 172, column 0 to column 10)",
                                                      " (in 'string', line 173, column 7 to column 12)",
                                                      " (in 'string', line 173, column 13 to column 14)",
                                                      " (in 'string', line 173, column 0 to column 26)",
                                                      " (in 'string', line 174, column 0 to column 21)",
                                                      " (in 'string', line 175, column 0 to column 38)",
                                                      " (in 'string', line 176, column 0 to column 14)",
                                                      " (in 'string', line 177, column 0 to column 16)",
                                                      " (in 'string', line 178, column 0 to column 17)",
                                                      " (in 'string', line 179, column 6 to column 7)",
                                                      " (in 'string', line 179, column 0 to column 23)",
                                                      " (in 'string', line 180, column 7 to column 8)",
                                                      " (in 'string', line 180, column 0 to column 19)",
                                                      " (in 'string', line 181, column 0 to column 23)",
                                                      " (in 'string', line 182, column 6 to column 7)",
                                                      " (in 'string', line 182, column 16 to column 17)",
                                                      " (in 'string', line 182, column 0 to column 24)",
                                                      " (in 'string', line 183, column 6 to column 11)",
                                                      " (in 'string', line 183, column 12 to column 13)",
                                                      " (in 'string', line 183, column 0 to column 59)",
                                                      " (in 'string', line 184, column 0 to column 8)",
                                                      " (in 'string', line 185, column 6 to column 11)",
                                                      " (in 'string', line 185, column 0 to column 21)",
                                                      " (in 'string', line 186, column 6 to column 11)",
                                                      " (in 'string', line 186, column 0 to column 34)",
                                                      " (in 'string', line 187, column 6 to column 11)",
                                                      " (in 'string', line 187, column 0 to column 35)",
                                                      " (in 'string', line 188, column 18 to column 23)",
                                                      " (in 'string', line 188, column 0 to column 29)",
                                                      " (in 'string', line 189, column 11 to column 12)",
                                                      " (in 'string', line 189, column 0 to column 33)",
                                                      " (in 'string', line 191, column 0 to column 23)",
                                                      " (in 'string', line 192, column 0 to column 23)",
                                                      " (in 'string', line 202, column 0 to column 51)",
                                                      " (in 'string', line 218, column 0 to column 48)",
                                                      " (in 'string', line 219, column 0 to column 36)",
                                                      " (in 'string', line 220, column 0 to column 37)",
                                                      " (in 'string', line 221, column 0 to column 34)",
                                                      " (in 'string', line 222, column 0 to column 37)",
                                                      " (in 'string', line 223, column 0 to column 36)",
                                                      " (in 'string', line 239, column 0 to column 51)",
                                                      " (in 'string', line 240, column 0 to column 39)",
                                                      " (in 'string', line 241, column 0 to column 40)",
                                                      " (in 'string', line 242, column 0 to column 37)",
                                                      " (in 'string', line 243, column 0 to column 40)",
                                                      " (in 'string', line 244, column 0 to column 39)",
                                                      " (in 'string', line 245, column 0 to column 29)",
                                                      " (in 'string', line 246, column 0 to column 29)",
                                                      " (in 'string', line 247, column 0 to column 40)",
                                                      " (in 'string', line 248, column 0 to column 37)",
                                                      " (in 'string', line 251, column 18 to column 23)",
                                                      " (in 'string', line 251, column 0 to column 33)",
                                                      " (in 'string', line 252, column 0 to column 17)",
                                                      " (in 'string', line 253, column 6 to column 19)",
                                                      " (in 'string', line 253, column 0 to column 30)",
                                                      " (in 'string', line 254, column 0 to column 22)",
                                                      " (in 'string', line 255, column 0 to column 20)",
                                                      " (in 'string', line 256, column 6 to column 17)",
                                                      " (in 'string', line 256, column 0 to column 59)",
                                                      " (in 'string', line 257, column 7 to column 8)",
                                                      " (in 'string', line 257, column 0 to column 45)",
                                                      " (in 'string', line 258, column 7 to column 19)",
                                                      " (in 'string', line 258, column 0 to column 60)",
                                                      " (in 'string', line 260, column 20 to column 52)",
                                                      " (in 'string', line 260, column 0 to column 52)",
                                                      " (in 'string', line 261, column 0 to column 11)",
                                                      " (in 'string', line 262, column 0 to column 15)",
                                                      " (in 'string', line 263, column 0 to column 17)",
                                                      " (in 'string', line 264, column 0 to column 22)",
                                                      " (in 'string', line 265, column 0 to column 37)",
                                                      " (in 'string', line 266, column 0 to column 48)",
                                                      " (in 'string', line 267, column 0 to column 30)",
                                                      " (in 'string', line 268, column 0 to column 32)",
                                                      " (in 'string', line 272, column 6 to column 7)",
                                                      " (in 'string', line 273, column 6 to column 23)",
                                                      " (in 'string', line 275, column 6 to column 7)",
                                                      " (in 'string', line 277, column 7 to column 19)",
                                                      " (in 'string', line 280, column 7 to column 16)",
                                                      " (in 'string', line 280, column 18 to column 19)",
                                                      " (in 'string', line 282, column 18 to column 23)",
                                                      " (in 'string', line 282, column 25 to column 26)",
                                                      " (in 'string', line 283, column 6 to column 13)",
                                                      " (in 'string', line 284, column 6 to column 23)",
                                                      " (in 'string', line 285, column 6 to column 11)",
                                                      " (in 'string', line 285, column 13 to column 24)",
                                                      " (in 'string', line 286, column 7 to column 12)",
                                                      " (in 'string', line 286, column 14 to column 15)",
                                                      " (in 'string', line 287, column 18 to column 23)",
                                                      " (in 'string', line 287, column 25 to column 26)",
                                                      " (in 'string', line 288, column 18 to column 23)",
                                                      " (in 'string', line 288, column 25 to column 26)",
                                                      " (in 'string', line 289, column 7 to column 8)",
                                                      " (in 'string', line 289, column 10 to column 11)",
                                                      " (in 'string', line 290, column 7 to column 8)",
                                                      " (in 'string', line 290, column 10 to column 11)",
                                                      " (in 'string', line 292, column 7 to column 8)",
                                                      " (in 'string', line 292, column 10 to column 11)",
                                                      " (in 'string', line 293, column 7 to column 8)",
                                                      " (in 'string', line 293, column 10 to column 11)",
                                                      " (in 'string', line 294, column 7 to column 20)",
                                                      " (in 'string', line 294, column 22 to column 23)",
                                                      " (in 'string', line 364, column 7 to column 12)",
                                                      " (in 'string', line 365, column 7 to column 12)",
                                                      " (in 'string', line 366, column 7 to column 12)",
                                                      " (in 'string', line 366, column 14 to column 15)",
                                                      " (in 'string', line 368, column 7 to column 12)",
                                                      " (in 'string', line 368, column 13 to column 14)",
                                                      " (in 'string', line 369, column 7 to column 12)",
                                                      " (in 'string', line 4, column 8 to column 9)",
                                                      " (in 'string', line 4, column 11 to column 12)",
                                                      " (in 'string', line 4, column 1 to column 40)",
                                                      " (in 'string', line 5, column 1 to column 13)",
                                                      " (in 'string', line 8, column 4 to column 25)",
                                                      " (in 'string', line 9, column 4 to column 13)",
                                                      " (in 'string', line 7, column 21 to line 10, column 3)",
                                                      " (in 'string', line 7, column 2 to line 10, column 3)",
                                                      " (in 'string', line 6, column 18 to line 11, column 2)",
                                                      " (in 'string', line 6, column 1 to line 11, column 2)",
                                                      " (in 'string', line 12, column 1 to column 10)",
                                                      " (in 'string', line 3, column 38 to line 13, column 1)",
                                                      " (in 'string', line 15, column 2 to column 22)",
                                                      " (in 'string', line 16, column 2 to column 22)",
                                                      " (in 'string', line 17, column 9 to column 14)",
                                                      " (in 'string', line 17, column 16 to column 17)",
                                                      " (in 'string', line 17, column 2 to column 26)",
                                                      " (in 'string', line 18, column 2 to column 14)",
                                                      " (in 'string', line 21, column 6 to column 46)",
                                                      " (in 'string', line 22, column 6 to column 15)",
                                                      " (in 'string', line 20, column 18 to line 23, column 4)",
                                                      " (in 'string', line 20, column 3 to line 23, column 4)",
                                                      " (in 'string', line 19, column 16 to line 24, column 2)",
                                                      " (in 'string', line 19, column 1 to line 24, column 2)",
                                                      " (in 'string', line 25, column 2 to column 16)",
                                                      " (in 'string', line 14, column 42 to line 26, column 1)",
                                                      " (in 'string', line 28, column 2 to column 30)",
                                                      " (in 'string', line 29, column 9 to column 10)",
                                                      " (in 'string', line 29, column 12 to column 13)",
                                                      " (in 'string', line 29, column 2 to column 22)",
                                                      " (in 'string', line 30, column 2 to column 14)",
                                                      " (in 'string', line 32, column 4 to column 25)",
                                                      " (in 'string', line 33, column 4 to column 13)",
                                                      " (in 'string', line 31, column 17 to line 34, column 3)",
                                                      " (in 'string', line 31, column 2 to line 34, column 3)",
                                                      " (in 'string', line 35, column 2 to column 16)",
                                                      " (in 'string', line 27, column 52 to line 36, column 1)",
                                                      " (in 'string', line 38, column 1 to column 17)",
                                                      " (in 'string', line 39, column 7 to column 12)",
                                                      " (in 'string', line 39, column 1 to column 21)",
                                                      " (in 'string', line 40, column 1 to column 13)",
                                                      " (in 'string', line 43, column 2 to column 16)",
                                                      " (in 'string', line 44, column 2 to column 11)",
                                                      " (in 'string', line 42, column 18 to line 45, column 4)",
                                                      " (in 'string', line 42, column 3 to line 45, column 4)",
                                                      " (in 'string', line 41, column 16 to line 46, column 2)",
                                                      " (in 'string', line 41, column 1 to line 46, column 2)",
                                                      " (in 'string', line 47, column 1 to column 10)",
                                                      " (in 'string', line 37, column 45 to line 48, column 1)",
                                                      " (in 'string', line 50, column 8 to column 23)",
                                                      " (in 'string', line 50, column 2 to column 34)",
                                                      " (in 'string', line 51, column 2 to column 8)",
                                                      " (in 'string', line 52, column 2 to column 8)",
                                                      " (in 'string', line 53, column 2 to column 14)",
                                                      " (in 'string', line 54, column 2 to column 14)",
                                                      " (in 'string', line 55, column 32 to column 63)",
                                                      " (in 'string', line 55, column 17 to column 63)",
                                                      " (in 'string', line 55, column 2 to column 63)",
                                                      " (in 'string', line 56, column 2 to column 13)",
                                                      " (in 'string', line 49, column 41 to line 57, column 1)",
                                                      " (in 'string', line 59, column 8 to column 23)",
                                                      " (in 'string', line 59, column 2 to column 34)",
                                                      " (in 'string', line 60, column 2 to column 8)",
                                                      " (in 'string', line 61, column 2 to column 8)",
                                                      " (in 'string', line 62, column 2 to column 14)",
                                                      " (in 'string', line 63, column 2 to column 14)",
                                                      " (in 'string', line 64, column 32 to column 63)",
                                                      " (in 'string', line 64, column 17 to column 63)",
                                                      " (in 'string', line 64, column 2 to column 63)",
                                                      " (in 'string', line 65, column 2 to column 13)",
                                                      " (in 'string', line 58, column 41 to line 66, column 1)",
                                                      " (in 'string', line 74, column 2 to column 17)",
                                                      " (in 'string', line 75, column 2 to column 21)",
                                                      " (in 'string', line 76, column 2 to column 23)",
                                                      " (in 'string', line 77, column 8 to column 19)",
                                                      " (in 'string', line 77, column 2 to column 32)",
                                                      " (in 'string', line 78, column 8 to column 9)",
                                                      " (in 'string', line 78, column 2 to column 22)",
                                                      " (in 'string', line 79, column 8 to column 13)",
                                                      " (in 'string', line 79, column 2 to column 25)",
                                                      " (in 'string', line 80, column 8 to column 9)",
                                                      " (in 'string', line 80, column 2 to column 64)",
                                                      " (in 'string', line 82, column 8 to column 13)",
                                                      " (in 'string', line 82, column 2 to column 47)",
                                                      " (in 'string', line 84, column 2 to column 32)",
                                                      " (in 'string', line 85, column 2 to column 30)",
                                                      " (in 'string', line 86, column 2 to column 29)",
                                                      " (in 'string', line 87, column 8 to column 9)",
                                                      " (in 'string', line 87, column 2 to column 56)",
                                                      " (in 'string', line 90, column 1 to column 32)",
                                                      " (in 'string', line 91, column 1 to column 32)",
                                                      " (in 'string', line 93, column 1 to line 95, column 81)",
                                                      " (in 'string', line 97, column 1 to column 44)",
                                                      " (in 'string', line 99, column 1 to column 81)",
                                                      " (in 'string', line 101, column 1 to column 72)",
                                                      " (in 'string', line 103, column 1 to column 62)",
                                                      " (in 'string', line 105, column 1 to column 68)",
                                                      " (in 'string', line 107, column 1 to column 49)",
                                                      " (in 'string', line 89, column 16 to line 108, column 4)",
                                                      " (in 'string', line 89, column 2 to line 108, column 4)",
                                                      " (in 'string', line 109, column 2 to column 15)",
                                                      " (in 'string', line 73, column 7 to line 110, column 1)",
                                                      " (in 'string', line 120, column 2 to column 9)",
                                                      " (in 'string', line 121, column 9 to column 24)",
                                                      " (in 'string', line 121, column 2 to column 45)",
                                                      " (in 'string', line 122, column 9 to column 24)",
                                                      " (in 'string', line 122, column 2 to column 34)",
                                                      " (in 'string', line 123, column 9 to column 24)",
                                                      " (in 'string', line 123, column 2 to column 28)",
                                                      " (in 'string', line 124, column 8 to column 19)",
                                                      " (in 'string', line 124, column 20 to column 35)",
                                                      " (in 'string', line 124, column 2 to column 51)",
                                                      " (in 'string', line 125, column 2 to column 17)",
                                                      " (in 'string', line 126, column 2 to column 21)",
                                                      " (in 'string', line 127, column 8 to column 19)",
                                                      " (in 'string', line 127, column 2 to column 36)",
                                                      " (in 'string', line 128, column 8 to column 13)",
                                                      " (in 'string', line 128, column 2 to column 42)",
                                                      " (in 'string', line 129, column 8 to column 13)",
                                                      " (in 'string', line 129, column 2 to column 57)",
                                                      " (in 'string', line 130, column 8 to column 15)",
                                                      " (in 'string', line 130, column 2 to column 73)",
                                                      " (in 'string', line 132, column 2 to column 42)",
                                                      " (in 'string', line 133, column 2 to column 42)",
                                                      " (in 'string', line 134, column 2 to column 50)",
                                                      " (in 'string', line 135, column 2 to column 50)",
                                                      " (in 'string', line 149, column 2 to column 30)",
                                                      " (in 'string', line 153, column 46 to column 106)",
                                                      " (in 'string', line 153, column 8 to column 106)",
                                                      " (in 'string', line 152, column 32 to column 96)",
                                                      " (in 'string', line 152, column 3 to line 153, column 106)",
                                                      " (in 'string', line 150, column 16 to line 154, column 3)",
                                                      " (in 'string', line 150, column 2 to line 154, column 3)",
                                                      " (in 'string', line 155, column 2 to column 78)",
                                                      " (in 'string', line 156, column 2 to column 16)",
                                                      " (in 'string', line 157, column 2 to line 162, column 25)",
                                                      " (in 'string', line 148, column 8 to line 163, column 2)",
                                                      " (in 'string', line 138, column 19 to column 63)",
                                                      " (in 'string', line 138, column 4 to column 63)",
                                                      " (in 'string', line 139, column 4 to column 32)",
                                                      " (in 'string', line 140, column 4 to column 93)",
                                                      " (in 'string', line 141, column 4 to column 29)",
                                                      " (in 'string', line 142, column 4 to line 147, column 40)",
                                                      " (in 'string', line 137, column 11 to line 148, column 2)",
                                                      " (in 'string', line 137, column 1 to line 163, column 2)",
                                                      " (in 'string', line 136, column 31 to line 164, column 3)",
                                                      " (in 'string', line 136, column 2 to line 164, column 3)",
                                                      " (in 'string', line 165, column 2 to column 18)",
                                                      " (in 'string', line 119, column 0 to line 166, column 1)"};
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
to_triangular(const T0__& x_arg__, const int& K, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& x = to_ref(x_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 216;
    validate_non_negative_index("y", "K", K);
    current_statement__ = 217;
    validate_non_negative_index("y", "K", K);
    Eigen::Matrix<local_scalar_t__, -1, -1> y;
    y = Eigen::Matrix<local_scalar_t__, -1, -1>(K, K);
    stan::math::fill(y, DUMMY_VAR__);
    
    current_statement__ = 218;
    assign(y, nil_index_list(), rep_matrix(0.0, K, K), "assigning variable y");
    int pos;
    pos = std::numeric_limits<int>::min();
    
    current_statement__ = 219;
    pos = 1;
    current_statement__ = 225;
    for (int col = 1; col <= K; ++col) {
      current_statement__ = 223;
      for (int row = col; row <= K; ++row) {
        current_statement__ = 220;
        assign(y,
          cons_list(index_uni(row),
            cons_list(index_uni(col), nil_index_list())), x[(pos - 1)],
          "assigning variable y");
        current_statement__ = 221;
        pos = (pos + 1);}}
    current_statement__ = 226;
    return y;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct to_triangular_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
operator()(const T0__& x, const int& K, std::ostream* pstream__)  const 
{
return to_triangular(x, K, pstream__);
}
};
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
repeat_matrix(const T0__& input_arg__, const int& K, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& input = to_ref(input_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int N;
    N = std::numeric_limits<int>::min();
    
    current_statement__ = 228;
    N = rows(input);
    int M;
    M = std::numeric_limits<int>::min();
    
    current_statement__ = 229;
    M = cols(input);
    current_statement__ = 230;
    validate_non_negative_index("repmat", "N * K", (N * K));
    current_statement__ = 231;
    validate_non_negative_index("repmat", "M", M);
    Eigen::Matrix<local_scalar_t__, -1, -1> repmat;
    repmat = Eigen::Matrix<local_scalar_t__, -1, -1>((N * K), M);
    stan::math::fill(repmat, DUMMY_VAR__);
    
    int pos;
    pos = std::numeric_limits<int>::min();
    
    current_statement__ = 233;
    pos = 1;
    current_statement__ = 239;
    for (int n = 1; n <= N; ++n) {
      current_statement__ = 237;
      for (int k = 1; k <= K; ++k) {
        current_statement__ = 234;
        assign(repmat,
          cons_list(index_uni(pos),
            cons_list(index_omni(), nil_index_list())),
          to_row_vector(
            rvalue(input,
              cons_list(index_uni(n),
                cons_list(index_omni(), nil_index_list())), "input")),
          "assigning variable repmat");
        current_statement__ = 235;
        pos = (pos + 1);}}
    current_statement__ = 240;
    return repmat;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct repeat_matrix_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
operator()(const T0__& input, const int& K, std::ostream* pstream__)  const 
{
return repeat_matrix(input, K, pstream__);
}
};
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
repeat_rv_to_matrix(const T0__& input_arg__, const int& K,
                    std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& input = to_ref(input_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int M;
    M = std::numeric_limits<int>::min();
    
    current_statement__ = 242;
    M = num_elements(input);
    current_statement__ = 243;
    validate_non_negative_index("repmat", "K", K);
    current_statement__ = 244;
    validate_non_negative_index("repmat", "M", M);
    Eigen::Matrix<local_scalar_t__, -1, -1> repmat;
    repmat = Eigen::Matrix<local_scalar_t__, -1, -1>(K, M);
    stan::math::fill(repmat, DUMMY_VAR__);
    
    int pos;
    pos = std::numeric_limits<int>::min();
    
    current_statement__ = 246;
    pos = 1;
    current_statement__ = 250;
    for (int k = 1; k <= K; ++k) {
      current_statement__ = 247;
      assign(repmat,
        cons_list(index_uni(pos), cons_list(index_omni(), nil_index_list())),
        input, "assigning variable repmat");
      current_statement__ = 248;
      pos = (pos + 1);}
    current_statement__ = 251;
    return repmat;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct repeat_rv_to_matrix_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
operator()(const T0__& input, const int& K, std::ostream* pstream__)  const 
{
return repeat_rv_to_matrix(input, K, pstream__);
}
};
template <typename T0__>
std::vector<stan::promote_args_t<T0__>>
rep_each(const std::vector<T0__>& x, const int& K, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int N;
    N = std::numeric_limits<int>::min();
    
    current_statement__ = 253;
    N = stan::math::size(x);
    current_statement__ = 254;
    validate_non_negative_index("y", "N * K", (N * K));
    std::vector<local_scalar_t__> y;
    y = std::vector<local_scalar_t__>((N * K), DUMMY_VAR__);
    
    int pos;
    pos = std::numeric_limits<int>::min();
    
    current_statement__ = 256;
    pos = 1;
    current_statement__ = 262;
    for (int n = 1; n <= N; ++n) {
      current_statement__ = 260;
      for (int k = 1; k <= K; ++k) {
        current_statement__ = 257;
        assign(y, cons_list(index_uni(pos), nil_index_list()), x[(n - 1)],
          "assigning variable y");
        current_statement__ = 258;
        pos = (pos + 1);}}
    current_statement__ = 263;
    return y;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct rep_each_functor__ {
template <typename T0__>
std::vector<stan::promote_args_t<T0__>>
operator()(const std::vector<T0__>& x, const int& K, std::ostream* pstream__)  const 
{
return rep_each(x, K, pstream__);
}
};
template <typename T0__>
std::vector<stan::promote_args_t<stan::value_type_t<T0__>>>
to_vector_rowwise(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& x = to_ref(x_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 265;
    validate_non_negative_index("res", "num_elements(x)", num_elements(x));
    std::vector<local_scalar_t__> res;
    res = std::vector<local_scalar_t__>(num_elements(x), DUMMY_VAR__);
    
    int n;
    n = std::numeric_limits<int>::min();
    
    int m;
    m = std::numeric_limits<int>::min();
    
    current_statement__ = 269;
    n = rows(x);
    current_statement__ = 270;
    m = cols(x);
    current_statement__ = 273;
    for (int i = 1; i <= n; ++i) {
      current_statement__ = 272;
      for (int j = 1; j <= m; ++j) {
        current_statement__ = 271;
        assign(res,
          cons_list(index_uni((((i - 1) * m) + j)), nil_index_list()),
          rvalue(x,
            cons_list(index_uni(i),
              cons_list(index_uni(j), nil_index_list())), "x"),
          "assigning variable res");}}
    current_statement__ = 274;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct to_vector_rowwise_functor__ {
template <typename T0__>
std::vector<stan::promote_args_t<stan::value_type_t<T0__>>>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return to_vector_rowwise(x, pstream__);
}
};
template <typename T0__>
std::vector<stan::promote_args_t<stan::value_type_t<T0__>>>
to_vector_colwise(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  const auto& x = to_ref(x_arg__);
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    current_statement__ = 276;
    validate_non_negative_index("res", "num_elements(x)", num_elements(x));
    std::vector<local_scalar_t__> res;
    res = std::vector<local_scalar_t__>(num_elements(x), DUMMY_VAR__);
    
    int n;
    n = std::numeric_limits<int>::min();
    
    int m;
    m = std::numeric_limits<int>::min();
    
    current_statement__ = 280;
    n = rows(x);
    current_statement__ = 281;
    m = cols(x);
    current_statement__ = 284;
    for (int i = 1; i <= n; ++i) {
      current_statement__ = 283;
      for (int j = 1; j <= m; ++j) {
        current_statement__ = 282;
        assign(res,
          cons_list(index_uni(((n * (j - 1)) + i)), nil_index_list()),
          rvalue(x,
            cons_list(index_uni(i),
              cons_list(index_uni(j), nil_index_list())), "x"),
          "assigning variable res");}}
    current_statement__ = 285;
    return res;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct to_vector_colwise_functor__ {
template <typename T0__>
std::vector<stan::promote_args_t<stan::value_type_t<T0__>>>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return to_vector_colwise(x, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
ODE_states(const T0__& time, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    int A;
    A = std::numeric_limits<int>::min();
    
    current_statement__ = 287;
    A = x_i[(1 - 1)];
    int n_obs;
    n_obs = std::numeric_limits<int>::min();
    
    current_statement__ = 288;
    n_obs = x_i[(2 - 1)];
    int n_difeq;
    n_difeq = std::numeric_limits<int>::min();
    
    current_statement__ = 289;
    n_difeq = x_i[(3 - 1)];
    current_statement__ = 290;
    validate_non_negative_index("dy_dt", "A * n_difeq", (A * n_difeq));
    std::vector<local_scalar_t__> dy_dt;
    dy_dt = std::vector<local_scalar_t__>((A * n_difeq), DUMMY_VAR__);
    
    current_statement__ = 292;
    validate_non_negative_index("f_inf", "A", A);
    std::vector<local_scalar_t__> f_inf;
    f_inf = std::vector<local_scalar_t__>(A, DUMMY_VAR__);
    
    current_statement__ = 294;
    validate_non_negative_index("init", "2 * A", (2 * A));
    std::vector<local_scalar_t__> init;
    init = std::vector<local_scalar_t__>((2 * A), DUMMY_VAR__);
    
    current_statement__ = 296;
    validate_non_negative_index("age_dist", "A", A);
    std::vector<local_scalar_t__> age_dist;
    age_dist = std::vector<local_scalar_t__>(A, DUMMY_VAR__);
    
    current_statement__ = 297;
    assign(age_dist, nil_index_list(),
      rvalue(x_r,
        cons_list(index_min_max(((2 * n_obs) + 1), ((2 * n_obs) + A)),
          nil_index_list()), "x_r"), "assigning variable age_dist");
    current_statement__ = 298;
    validate_non_negative_index("contact", "A * A", (A * A));
    std::vector<local_scalar_t__> contact;
    contact = std::vector<local_scalar_t__>((A * A), DUMMY_VAR__);
    
    current_statement__ = 299;
    assign(contact, nil_index_list(),
      rvalue(theta, cons_list(index_min_max(1, (A * A)), nil_index_list()),
        "theta"), "assigning variable contact");
    local_scalar_t__ gamma;
    gamma = DUMMY_VAR__;
    
    current_statement__ = 300;
    gamma = theta[(((A * A) + 1) - 1)];
    local_scalar_t__ tau;
    tau = DUMMY_VAR__;
    
    current_statement__ = 301;
    tau = theta[(((A * A) + 2) - 1)];
    local_scalar_t__ pi;
    pi = DUMMY_VAR__;
    
    current_statement__ = 302;
    pi = theta[(((A * A) + 3) - 1)];
    current_statement__ = 303;
    validate_non_negative_index("beta", "A", A);
    std::vector<local_scalar_t__> beta;
    beta = std::vector<local_scalar_t__>(A, DUMMY_VAR__);
    
    current_statement__ = 304;
    assign(beta, nil_index_list(),
      rvalue(theta,
        cons_list(index_min_max(((A * A) + 4), (((A * A) + A) + 3)),
          nil_index_list()), "theta"), "assigning variable beta");
    current_statement__ = 315;
    for (int i = 1; i <= A; ++i) {
      current_statement__ = 305;
      assign(init, cons_list(index_uni(i), nil_index_list()),
        (age_dist[(i - 1)] * (1 - pi)), "assigning variable init");
      current_statement__ = 306;
      assign(init, cons_list(index_uni((A + i)), nil_index_list()),
        (age_dist[(i - 1)] * pi), "assigning variable init");
      current_statement__ = 307;
      assign(f_inf, cons_list(index_uni(i), nil_index_list()),
        sum(
          elt_multiply(
            elt_divide(
              elt_multiply(to_vector(beta),
                add(
                  to_vector(
                    rvalue(y,
                      cons_list(index_min_max(((3 * A) + 1), (4 * A)),
                        nil_index_list()), "y")),
                  to_vector(
                    rvalue(y,
                      cons_list(index_min_max(((4 * A) + 1), (5 * A)),
                        nil_index_list()), "y")))), to_vector(age_dist)),
            to_vector(
              rvalue(contact,
                cons_list(index_min_max(((A * (i - 1)) + 1), (i * A)),
                  nil_index_list()), "contact")))),
        "assigning variable f_inf");
      current_statement__ = 308;
      assign(dy_dt, cons_list(index_uni(i), nil_index_list()),
        (-f_inf[(i - 1)] * (y[(i - 1)] + init[(i - 1)])),
        "assigning variable dy_dt");
      current_statement__ = 309;
      assign(dy_dt, cons_list(index_uni((A + i)), nil_index_list()),
        ((f_inf[(i - 1)] * (y[(i - 1)] + init[(i - 1)])) -
          (tau * (y[((A + i) - 1)] + init[((A + i) - 1)]))),
        "assigning variable dy_dt");
      current_statement__ = 310;
      assign(dy_dt, cons_list(index_uni(((2 * A) + i)), nil_index_list()),
        (tau *
          ((y[((A + i) - 1)] + init[((A + i) - 1)]) - y[(((2 * A) + i) - 1)])),
        "assigning variable dy_dt");
      current_statement__ = 311;
      assign(dy_dt, cons_list(index_uni(((3 * A) + i)), nil_index_list()),
        ((tau * y[(((2 * A) + i) - 1)]) - (gamma * y[(((3 * A) + i) - 1)])),
        "assigning variable dy_dt");
      current_statement__ = 312;
      assign(dy_dt, cons_list(index_uni(((4 * A) + i)), nil_index_list()),
        (gamma * (y[(((3 * A) + i) - 1)] - (gamma * y[(((4 * A) + i) - 1)]))),
        "assigning variable dy_dt");
      current_statement__ = 313;
      assign(dy_dt,
        cons_list(index_uni((((n_difeq - 1) * A) + i)), nil_index_list()),
        (tau * y[(((2 * A) + i) - 1)]), "assigning variable dy_dt");}
    current_statement__ = 316;
    return dy_dt;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct ODE_states_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<stan::promote_args_t<T0__, T1__, T2__,
T3__>>
operator()(const T0__& time, const std::vector<T1__>& y,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__)  const 
{
return ODE_states(time, y, theta, x_r, x_i, pstream__);
}
};
template <typename T0__, typename T1__, typename T2__, typename T3__,
typename T4__>
std::vector<std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__,
T4__>>>
integrate_ode_trapezoidal(const std::vector<T0__>& y_initial,
                          const T1__& initial_time,
                          const std::vector<T2__>& times,
                          const std::vector<T3__>& theta,
                          const std::vector<T4__>& x_r,
                          const std::vector<int>& x_i,
                          std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__,
          T1__,
          T2__,
          T3__,
          T4__>;
  const static bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  
  try {
    local_scalar_t__ h;
    h = DUMMY_VAR__;
    
    current_statement__ = 319;
    validate_non_negative_index("dy_dt_initial_time", "size(y_initial)",
                                stan::math::size(y_initial));
    Eigen::Matrix<local_scalar_t__, -1, 1> dy_dt_initial_time;
    dy_dt_initial_time = Eigen::Matrix<local_scalar_t__, -1, 1>(stan::math::size(
                                                                  y_initial));
    stan::math::fill(dy_dt_initial_time, DUMMY_VAR__);
    
    current_statement__ = 321;
    validate_non_negative_index("dy_dt_t", "size(y_initial)",
                                stan::math::size(y_initial));
    Eigen::Matrix<local_scalar_t__, -1, 1> dy_dt_t;
    dy_dt_t = Eigen::Matrix<local_scalar_t__, -1, 1>(stan::math::size(
                                                       y_initial));
    stan::math::fill(dy_dt_t, DUMMY_VAR__);
    
    current_statement__ = 323;
    validate_non_negative_index("k", "size(y_initial)",
                                stan::math::size(y_initial));
    Eigen::Matrix<local_scalar_t__, -1, 1> k;
    k = Eigen::Matrix<local_scalar_t__, -1, 1>(stan::math::size(y_initial));
    stan::math::fill(k, DUMMY_VAR__);
    
    current_statement__ = 325;
    validate_non_negative_index("y_approx", "size(times)",
                                stan::math::size(times));
    current_statement__ = 326;
    validate_non_negative_index("y_approx", "size(y_initial)",
                                stan::math::size(y_initial));
    std::vector<std::vector<local_scalar_t__>> y_approx;
    y_approx = std::vector<std::vector<local_scalar_t__>>(stan::math::size(
                                                            times), std::vector<local_scalar_t__>(
      stan::math::size(y_initial), DUMMY_VAR__));
    
    int A;
    A = std::numeric_limits<int>::min();
    
    current_statement__ = 328;
    A = x_i[(1 - 1)];
    int n_obs;
    n_obs = std::numeric_limits<int>::min();
    
    current_statement__ = 329;
    n_obs = x_i[(2 - 1)];
    current_statement__ = 330;
    validate_non_negative_index("theta_ODE", "A * A + A + 3",
                                (((A * A) + A) + 3));
    std::vector<local_scalar_t__> theta_ODE;
    theta_ODE = std::vector<local_scalar_t__>((((A * A) + A) + 3), DUMMY_VAR__);
    
    current_statement__ = 332;
    validate_non_negative_index("left_t", "n_obs", n_obs);
    std::vector<local_scalar_t__> left_t;
    left_t = std::vector<local_scalar_t__>(n_obs, DUMMY_VAR__);
    
    current_statement__ = 333;
    assign(left_t, nil_index_list(),
      rvalue(x_r, cons_list(index_min_max(1, n_obs), nil_index_list()),
        "x_r"), "assigning variable left_t");
    current_statement__ = 334;
    validate_non_negative_index("right_t", "n_obs", n_obs);
    std::vector<local_scalar_t__> right_t;
    right_t = std::vector<local_scalar_t__>(n_obs, DUMMY_VAR__);
    
    current_statement__ = 335;
    assign(right_t, nil_index_list(),
      rvalue(x_r,
        cons_list(index_min_max((n_obs + 1), (2 * n_obs)), nil_index_list()),
        "x_r"), "assigning variable right_t");
    current_statement__ = 336;
    validate_non_negative_index("beta_N_temp", "A * n_obs", (A * n_obs));
    std::vector<local_scalar_t__> beta_N_temp;
    beta_N_temp = std::vector<local_scalar_t__>((A * n_obs), DUMMY_VAR__);
    
    current_statement__ = 337;
    assign(beta_N_temp, nil_index_list(),
      rvalue(theta,
        cons_list(
          index_min_max(((A * A) + 3), (((A * n_obs) + (A * A)) + 2)),
          nil_index_list()), "theta"), "assigning variable beta_N_temp");
    current_statement__ = 338;
    assign(theta_ODE, cons_list(index_min_max(1, (A * A)), nil_index_list()),
      rvalue(theta, cons_list(index_min_max(1, (A * A)), nil_index_list()),
        "theta"), "assigning variable theta_ODE");
    current_statement__ = 339;
    assign(theta_ODE, cons_list(index_uni(((A * A) + 1)), nil_index_list()),
      theta[(((A * A) + 1) - 1)], "assigning variable theta_ODE");
    current_statement__ = 340;
    assign(theta_ODE, cons_list(index_uni(((A * A) + 2)), nil_index_list()),
      theta[((((A * n_obs) + (A * A)) + 4) - 1)],
      "assigning variable theta_ODE");
    current_statement__ = 341;
    assign(theta_ODE, cons_list(index_uni(((A * A) + 3)), nil_index_list()),
      theta[((((A * n_obs) + (A * A)) + 3) - 1)],
      "assigning variable theta_ODE");
    current_statement__ = 362;
    for (int t = 0; t <= (stan::math::size(times) - 1); ++t) {
      current_statement__ = 360;
      if (logical_eq(t, 0)) {
        current_statement__ = 354;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 353;
          assign(theta_ODE,
            cons_list(index_uni((((A * A) + 3) + j)), nil_index_list()),
            theta[(((A * A) + 2) - 1)], "assigning variable theta_ODE");}
        current_statement__ = 355;
        h = (times[(1 - 1)] - initial_time);
        current_statement__ = 356;
        assign(dy_dt_initial_time, nil_index_list(),
          to_vector(
            ODE_states(initial_time, y_initial, theta_ODE, x_r,
              x_i, pstream__)), "assigning variable dy_dt_initial_time");
        current_statement__ = 357;
        assign(k, nil_index_list(), multiply(h, dy_dt_initial_time),
          "assigning variable k");
        current_statement__ = 358;
        assign(y_approx,
          cons_list(index_uni((t + 1)),
            cons_list(index_omni(), nil_index_list())),
          to_array_1d(
            add(to_vector(y_initial),
              divide(
                multiply(h,
                  add(dy_dt_initial_time,
                    to_vector(
                      ODE_states(times[(1 - 1)],
                        to_array_1d(add(to_vector(y_initial), k)), theta_ODE,
                        x_r, x_i, pstream__)))), 2))),
          "assigning variable y_approx");
      } else {
        current_statement__ = 342;
        h = (times[((t + 1) - 1)] - times[(t - 1)]);
        current_statement__ = 348;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 346;
          if (logical_eq(t, (stan::math::size(times) - 1))) {
            current_statement__ = 345;
            assign(theta_ODE,
              cons_list(index_uni((((A * A) + 3) + j)), nil_index_list()),
              beta_N_temp[((((n_obs * (j - 1)) + t) + 1) - 1)],
              "assigning variable theta_ODE");
          } else {
            current_statement__ = 344;
            if ((primitive_value(logical_gte(t, left_t[(t - 1)])) &&
                primitive_value(logical_lte(t, right_t[(t - 1)])))) {
              current_statement__ = 343;
              assign(theta_ODE,
                cons_list(index_uni((((A * A) + 3) + j)), nil_index_list()),
                beta_N_temp[(((n_obs * (j - 1)) + t) - 1)],
                "assigning variable theta_ODE");
            } 
          }}
        current_statement__ = 349;
        assign(dy_dt_t, nil_index_list(),
          to_vector(
            ODE_states(times[(t - 1)], y_approx[(t - 1)], theta_ODE, x_r,
              x_i, pstream__)), "assigning variable dy_dt_t");
        current_statement__ = 350;
        assign(k, nil_index_list(), multiply(h, dy_dt_t),
          "assigning variable k");
        current_statement__ = 351;
        assign(y_approx,
          cons_list(index_uni((t + 1)),
            cons_list(index_omni(), nil_index_list())),
          to_array_1d(
            add(
              to_vector(
                stan::model::deep_copy(
                  rvalue(y_approx,
                    cons_list(index_uni(t),
                      cons_list(index_omni(), nil_index_list())), "y_approx"))),
              divide(
                multiply(h,
                  add(dy_dt_t,
                    to_vector(
                      ODE_states(times[((t + 1) - 1)],
                        to_array_1d(
                          add(
                            to_vector(
                              stan::model::deep_copy(
                                rvalue(y_approx,
                                  cons_list(index_uni(t),
                                    cons_list(index_omni(), nil_index_list())),
                                  "y_approx"))), k)), theta_ODE, x_r,
                        x_i, pstream__)))), 2))),
          "assigning variable y_approx");
      }}
    current_statement__ = 363;
    return y_approx;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}
struct integrate_ode_trapezoidal_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__,
typename T4__>
std::vector<std::vector<stan::promote_args_t<T0__, T1__, T2__, T3__,
T4__>>>
operator()(const std::vector<T0__>& y_initial, const T1__& initial_time,
           const std::vector<T2__>& times, const std::vector<T3__>& theta,
           const std::vector<T4__>& x_r, const std::vector<int>& x_i,
           std::ostream* pstream__)  const 
{
return integrate_ode_trapezoidal(y_initial, initial_time, times, theta, x_r,
         x_i, pstream__);
}
};
#include <stan_meta_header.hpp>
class model_igbm final : public model_base_crtp<model_igbm> {
private:
  int A;
  int n_obs;
  std::vector<std::vector<int>> y_data;
  int n_pop;
  int ecr_changes;
  int n_changes;
  int n_remainder;
  int L_raw_length;
  std::vector<double> age_dist;
  Eigen::Matrix<double, -1, 1> pop_diag;
  int n_difeq;
  std::vector<Eigen::Matrix<double, -1, 1>> L_cm;
  std::vector<std::vector<double>> age_specific_ifr;
  double t0;
  std::vector<double> ts;
  std::vector<double> left_t;
  std::vector<double> right_t;
  Eigen::Matrix<double, -1, 1> I_D;
  Eigen::Matrix<double, 1, -1> E_deathsByAge_day1;
  double incubation_period;
  double infectious_period;
  int likelihood_variance_type;
  int prior_dist_volatility;
  double prior_mean_volatility;
  double prior_scale_volatility;
  double prior_df_volatility;
  double prior_shape_volatility;
  double prior_rate_volatility;
  int prior_dist_nb_dispersion;
  double prior_mean_nb_dispersion;
  double prior_scale_nb_dispersion;
  double prior_df_nb_dispersion;
  double prior_shape_nb_dispersion;
  double prior_rate_nb_dispersion;
  double prior_scale_x0;
  double prior_scale_x1;
  double prior_scale_contactmatrix;
  Eigen::Matrix<double, -1, -1> prior_dist_pi;
  Eigen::Matrix<double, -1, 1> I_D_rev;
  std::vector<int> x_i;
  std::vector<double> x_r;
  double gamma;
  double tau;
  std::vector<double> init;
  Eigen::Matrix<double, -1, 1> ones_vector_A;
  Eigen::Matrix<double, -1, 1> L_vector;
  int x_noise_1dim__;
  int beta_N_1dim__;
  int theta_1dim__;
  int state_solutions_2dim__;
  int x_noise_mat_1dim__;
 
public:
  ~model_igbm() { }
  
  inline std::string model_name() const final { return "model_igbm"; }
  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.26.1-4-gd72b68b7-dirty", "stancflags = "};
  }
  
  
  model_igbm(stan::io::var_context& context__,
             unsigned int random_seed__ = 0,
             std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static const char* function__ = "model_igbm_namespace::model_igbm";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 107;
      context__.validate_dims("data initialization","A","int",
          context__.to_vec());
      A = std::numeric_limits<int>::min();
      
      current_statement__ = 107;
      A = context__.vals_i("A")[(1 - 1)];
      current_statement__ = 108;
      context__.validate_dims("data initialization","n_obs","int",
          context__.to_vec());
      n_obs = std::numeric_limits<int>::min();
      
      current_statement__ = 108;
      n_obs = context__.vals_i("n_obs")[(1 - 1)];
      current_statement__ = 109;
      validate_non_negative_index("y_data", "n_obs", n_obs);
      current_statement__ = 110;
      validate_non_negative_index("y_data", "A", A);
      current_statement__ = 111;
      context__.validate_dims("data initialization","y_data","int",
          context__.to_vec(n_obs, A));
      y_data = std::vector<std::vector<int>>(n_obs, std::vector<int>(A, std::numeric_limits<int>::min()));
      
      {
        std::vector<int> y_data_flat__;
        current_statement__ = 111;
        assign(y_data_flat__, nil_index_list(), context__.vals_i("y_data"),
          "assigning variable y_data_flat__");
        current_statement__ = 111;
        pos__ = 1;
        current_statement__ = 111;
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          current_statement__ = 111;
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            current_statement__ = 111;
            assign(y_data,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              y_data_flat__[(pos__ - 1)], "assigning variable y_data");
            current_statement__ = 111;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 112;
      context__.validate_dims("data initialization","n_pop","int",
          context__.to_vec());
      n_pop = std::numeric_limits<int>::min();
      
      current_statement__ = 112;
      n_pop = context__.vals_i("n_pop")[(1 - 1)];
      current_statement__ = 112;
      current_statement__ = 112;
      check_greater_or_equal(function__, "n_pop", n_pop, 1);
      current_statement__ = 113;
      context__.validate_dims("data initialization","ecr_changes","int",
          context__.to_vec());
      ecr_changes = std::numeric_limits<int>::min();
      
      current_statement__ = 113;
      ecr_changes = context__.vals_i("ecr_changes")[(1 - 1)];
      current_statement__ = 113;
      current_statement__ = 113;
      check_greater_or_equal(function__, "ecr_changes", ecr_changes, 1);
      current_statement__ = 113;
      current_statement__ = 113;
      check_less_or_equal(function__, "ecr_changes", ecr_changes, 7);
      current_statement__ = 114;
      context__.validate_dims("data initialization","n_changes","int",
          context__.to_vec());
      n_changes = std::numeric_limits<int>::min();
      
      current_statement__ = 114;
      n_changes = context__.vals_i("n_changes")[(1 - 1)];
      current_statement__ = 115;
      context__.validate_dims("data initialization","n_remainder","int",
          context__.to_vec());
      n_remainder = std::numeric_limits<int>::min();
      
      current_statement__ = 115;
      n_remainder = context__.vals_i("n_remainder")[(1 - 1)];
      current_statement__ = 116;
      context__.validate_dims("data initialization","L_raw_length","int",
          context__.to_vec());
      L_raw_length = std::numeric_limits<int>::min();
      
      current_statement__ = 116;
      L_raw_length = context__.vals_i("L_raw_length")[(1 - 1)];
      current_statement__ = 117;
      validate_non_negative_index("age_dist", "A", A);
      current_statement__ = 118;
      context__.validate_dims("data initialization","age_dist","double",
          context__.to_vec(A));
      age_dist = std::vector<double>(A, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 118;
      assign(age_dist, nil_index_list(), context__.vals_r("age_dist"),
        "assigning variable age_dist");
      current_statement__ = 119;
      validate_non_negative_index("pop_diag", "A", A);
      current_statement__ = 120;
      context__.validate_dims("data initialization","pop_diag","double",
          context__.to_vec(A));
      pop_diag = Eigen::Matrix<double, -1, 1>(A);
      stan::math::fill(pop_diag, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> pop_diag_flat__;
        current_statement__ = 120;
        assign(pop_diag_flat__, nil_index_list(),
          context__.vals_r("pop_diag"), "assigning variable pop_diag_flat__");
        current_statement__ = 120;
        pos__ = 1;
        current_statement__ = 120;
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          current_statement__ = 120;
          assign(pop_diag, cons_list(index_uni(sym1__), nil_index_list()),
            pop_diag_flat__[(pos__ - 1)], "assigning variable pop_diag");
          current_statement__ = 120;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 121;
      context__.validate_dims("data initialization","n_difeq","int",
          context__.to_vec());
      n_difeq = std::numeric_limits<int>::min();
      
      current_statement__ = 121;
      n_difeq = context__.vals_i("n_difeq")[(1 - 1)];
      current_statement__ = 121;
      current_statement__ = 121;
      check_greater_or_equal(function__, "n_difeq", n_difeq, 1);
      current_statement__ = 122;
      validate_non_negative_index("L_cm", "A", A);
      current_statement__ = 123;
      validate_non_negative_index("L_cm", "A", A);
      current_statement__ = 124;
      context__.validate_dims("data initialization","L_cm","double",
          context__.to_vec(A, A));
      L_cm = std::vector<Eigen::Matrix<double, -1, 1>>(A, Eigen::Matrix<double, -1, 1>(A));
      stan::math::fill(L_cm, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> L_cm_flat__;
        current_statement__ = 124;
        assign(L_cm_flat__, nil_index_list(), context__.vals_r("L_cm"),
          "assigning variable L_cm_flat__");
        current_statement__ = 124;
        pos__ = 1;
        current_statement__ = 124;
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          current_statement__ = 124;
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            current_statement__ = 124;
            assign(L_cm,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              L_cm_flat__[(pos__ - 1)], "assigning variable L_cm");
            current_statement__ = 124;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 125;
      validate_non_negative_index("age_specific_ifr", "n_obs", n_obs);
      current_statement__ = 126;
      validate_non_negative_index("age_specific_ifr", "A", A);
      current_statement__ = 127;
      context__.validate_dims("data initialization","age_specific_ifr",
          "double",context__.to_vec(n_obs, A));
      age_specific_ifr = std::vector<std::vector<double>>(n_obs, std::vector<double>(A, std::numeric_limits<double>::quiet_NaN()));
      
      {
        std::vector<local_scalar_t__> age_specific_ifr_flat__;
        current_statement__ = 127;
        assign(age_specific_ifr_flat__, nil_index_list(),
          context__.vals_r("age_specific_ifr"),
          "assigning variable age_specific_ifr_flat__");
        current_statement__ = 127;
        pos__ = 1;
        current_statement__ = 127;
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          current_statement__ = 127;
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            current_statement__ = 127;
            assign(age_specific_ifr,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              age_specific_ifr_flat__[(pos__ - 1)],
              "assigning variable age_specific_ifr");
            current_statement__ = 127;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 127;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 127;
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          current_statement__ = 127;
          current_statement__ = 127;
          check_greater_or_equal(function__,
                                 "age_specific_ifr[sym1__, sym2__]",
                                 age_specific_ifr[(sym1__ - 1)][(sym2__ - 1)],
                                 0);}}
      current_statement__ = 127;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 127;
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          current_statement__ = 127;
          current_statement__ = 127;
          check_less_or_equal(function__, "age_specific_ifr[sym1__, sym2__]",
                              age_specific_ifr[(sym1__ - 1)][(sym2__ - 1)], 1);
        }}
      current_statement__ = 128;
      context__.validate_dims("data initialization","t0","double",
          context__.to_vec());
      t0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 128;
      t0 = context__.vals_r("t0")[(1 - 1)];
      current_statement__ = 129;
      validate_non_negative_index("ts", "n_obs", n_obs);
      current_statement__ = 130;
      context__.validate_dims("data initialization","ts","double",
          context__.to_vec(n_obs));
      ts = std::vector<double>(n_obs, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 130;
      assign(ts, nil_index_list(), context__.vals_r("ts"),
        "assigning variable ts");
      current_statement__ = 131;
      validate_non_negative_index("left_t", "n_obs", n_obs);
      current_statement__ = 132;
      context__.validate_dims("data initialization","left_t","double",
          context__.to_vec(n_obs));
      left_t = std::vector<double>(n_obs, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 132;
      assign(left_t, nil_index_list(), context__.vals_r("left_t"),
        "assigning variable left_t");
      current_statement__ = 132;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 132;
        current_statement__ = 132;
        check_greater_or_equal(function__, "left_t[sym1__]",
                               left_t[(sym1__ - 1)], 0);}
      current_statement__ = 133;
      validate_non_negative_index("right_t", "n_obs", n_obs);
      current_statement__ = 134;
      context__.validate_dims("data initialization","right_t","double",
          context__.to_vec(n_obs));
      right_t = std::vector<double>(n_obs, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 134;
      assign(right_t, nil_index_list(), context__.vals_r("right_t"),
        "assigning variable right_t");
      current_statement__ = 134;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 134;
        current_statement__ = 134;
        check_greater_or_equal(function__, "right_t[sym1__]",
                               right_t[(sym1__ - 1)], 0);}
      current_statement__ = 135;
      validate_non_negative_index("I_D", "n_obs", n_obs);
      current_statement__ = 136;
      context__.validate_dims("data initialization","I_D","double",
          context__.to_vec(n_obs));
      I_D = Eigen::Matrix<double, -1, 1>(n_obs);
      stan::math::fill(I_D, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> I_D_flat__;
        current_statement__ = 136;
        assign(I_D_flat__, nil_index_list(), context__.vals_r("I_D"),
          "assigning variable I_D_flat__");
        current_statement__ = 136;
        pos__ = 1;
        current_statement__ = 136;
        for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
          current_statement__ = 136;
          assign(I_D, cons_list(index_uni(sym1__), nil_index_list()),
            I_D_flat__[(pos__ - 1)], "assigning variable I_D");
          current_statement__ = 136;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 136;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 136;
        current_statement__ = 136;
        check_greater_or_equal(function__, "I_D[sym1__]", I_D[(sym1__ - 1)],
                               0);}
      current_statement__ = 137;
      validate_non_negative_index("E_deathsByAge_day1", "A", A);
      current_statement__ = 138;
      context__.validate_dims("data initialization","E_deathsByAge_day1",
          "double",context__.to_vec(A));
      E_deathsByAge_day1 = Eigen::Matrix<double, 1, -1>(A);
      stan::math::fill(E_deathsByAge_day1, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> E_deathsByAge_day1_flat__;
        current_statement__ = 138;
        assign(E_deathsByAge_day1_flat__, nil_index_list(),
          context__.vals_r("E_deathsByAge_day1"),
          "assigning variable E_deathsByAge_day1_flat__");
        current_statement__ = 138;
        pos__ = 1;
        current_statement__ = 138;
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          current_statement__ = 138;
          assign(E_deathsByAge_day1,
            cons_list(index_uni(sym1__), nil_index_list()),
            E_deathsByAge_day1_flat__[(pos__ - 1)],
            "assigning variable E_deathsByAge_day1");
          current_statement__ = 138;
          pos__ = (pos__ + 1);}
      }
      current_statement__ = 139;
      context__.validate_dims("data initialization","incubation_period",
          "double",context__.to_vec());
      incubation_period = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 139;
      incubation_period = context__.vals_r("incubation_period")[(1 - 1)];
      current_statement__ = 140;
      context__.validate_dims("data initialization","infectious_period",
          "double",context__.to_vec());
      infectious_period = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 140;
      infectious_period = context__.vals_r("infectious_period")[(1 - 1)];
      current_statement__ = 141;
      context__.validate_dims("data initialization",
          "likelihood_variance_type","int",context__.to_vec());
      likelihood_variance_type = std::numeric_limits<int>::min();
      
      current_statement__ = 141;
      likelihood_variance_type = context__.vals_i("likelihood_variance_type")[
          (1 - 1)];
      current_statement__ = 141;
      current_statement__ = 141;
      check_greater_or_equal(function__, "likelihood_variance_type",
                             likelihood_variance_type, 0);
      current_statement__ = 141;
      current_statement__ = 141;
      check_less_or_equal(function__, "likelihood_variance_type",
                          likelihood_variance_type, 1);
      current_statement__ = 142;
      context__.validate_dims("data initialization","prior_dist_volatility",
          "int",context__.to_vec());
      prior_dist_volatility = std::numeric_limits<int>::min();
      
      current_statement__ = 142;
      prior_dist_volatility = context__.vals_i("prior_dist_volatility")[
          (1 - 1)];
      current_statement__ = 142;
      current_statement__ = 142;
      check_greater_or_equal(function__, "prior_dist_volatility",
                             prior_dist_volatility, 1);
      current_statement__ = 142;
      current_statement__ = 142;
      check_less_or_equal(function__, "prior_dist_volatility",
                          prior_dist_volatility, 5);
      current_statement__ = 143;
      context__.validate_dims("data initialization","prior_mean_volatility",
          "double",context__.to_vec());
      prior_mean_volatility = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 143;
      prior_mean_volatility = context__.vals_r("prior_mean_volatility")[
          (1 - 1)];
      current_statement__ = 143;
      current_statement__ = 143;
      check_greater_or_equal(function__, "prior_mean_volatility",
                             prior_mean_volatility, 0);
      current_statement__ = 144;
      context__.validate_dims("data initialization","prior_scale_volatility",
          "double",context__.to_vec());
      prior_scale_volatility = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 144;
      prior_scale_volatility = context__.vals_r("prior_scale_volatility")[
          (1 - 1)];
      current_statement__ = 144;
      current_statement__ = 144;
      check_greater_or_equal(function__, "prior_scale_volatility",
                             prior_scale_volatility, 0);
      current_statement__ = 145;
      context__.validate_dims("data initialization","prior_df_volatility",
          "double",context__.to_vec());
      prior_df_volatility = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 145;
      prior_df_volatility = context__.vals_r("prior_df_volatility")[(1 - 1)];
      current_statement__ = 145;
      current_statement__ = 145;
      check_greater_or_equal(function__, "prior_df_volatility",
                             prior_df_volatility, 0);
      current_statement__ = 146;
      context__.validate_dims("data initialization","prior_shape_volatility",
          "double",context__.to_vec());
      prior_shape_volatility = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 146;
      prior_shape_volatility = context__.vals_r("prior_shape_volatility")[
          (1 - 1)];
      current_statement__ = 146;
      current_statement__ = 146;
      check_greater_or_equal(function__, "prior_shape_volatility",
                             prior_shape_volatility, 0);
      current_statement__ = 147;
      context__.validate_dims("data initialization","prior_rate_volatility",
          "double",context__.to_vec());
      prior_rate_volatility = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 147;
      prior_rate_volatility = context__.vals_r("prior_rate_volatility")[
          (1 - 1)];
      current_statement__ = 147;
      current_statement__ = 147;
      check_greater_or_equal(function__, "prior_rate_volatility",
                             prior_rate_volatility, 0);
      current_statement__ = 148;
      context__.validate_dims("data initialization",
          "prior_dist_nb_dispersion","int",context__.to_vec());
      prior_dist_nb_dispersion = std::numeric_limits<int>::min();
      
      current_statement__ = 148;
      prior_dist_nb_dispersion = context__.vals_i("prior_dist_nb_dispersion")[
          (1 - 1)];
      current_statement__ = 148;
      current_statement__ = 148;
      check_greater_or_equal(function__, "prior_dist_nb_dispersion",
                             prior_dist_nb_dispersion, 1);
      current_statement__ = 148;
      current_statement__ = 148;
      check_less_or_equal(function__, "prior_dist_nb_dispersion",
                          prior_dist_nb_dispersion, 5);
      current_statement__ = 149;
      context__.validate_dims("data initialization",
          "prior_mean_nb_dispersion","double",context__.to_vec());
      prior_mean_nb_dispersion = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 149;
      prior_mean_nb_dispersion = context__.vals_r("prior_mean_nb_dispersion")[
          (1 - 1)];
      current_statement__ = 149;
      current_statement__ = 149;
      check_greater_or_equal(function__, "prior_mean_nb_dispersion",
                             prior_mean_nb_dispersion, 0);
      current_statement__ = 150;
      context__.validate_dims("data initialization",
          "prior_scale_nb_dispersion","double",context__.to_vec());
      prior_scale_nb_dispersion = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 150;
      prior_scale_nb_dispersion = context__.vals_r("prior_scale_nb_dispersion")[
          (1 - 1)];
      current_statement__ = 150;
      current_statement__ = 150;
      check_greater_or_equal(function__, "prior_scale_nb_dispersion",
                             prior_scale_nb_dispersion, 0);
      current_statement__ = 151;
      context__.validate_dims("data initialization","prior_df_nb_dispersion",
          "double",context__.to_vec());
      prior_df_nb_dispersion = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 151;
      prior_df_nb_dispersion = context__.vals_r("prior_df_nb_dispersion")[
          (1 - 1)];
      current_statement__ = 151;
      current_statement__ = 151;
      check_greater_or_equal(function__, "prior_df_nb_dispersion",
                             prior_df_nb_dispersion, 0);
      current_statement__ = 152;
      context__.validate_dims("data initialization",
          "prior_shape_nb_dispersion","double",context__.to_vec());
      prior_shape_nb_dispersion = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 152;
      prior_shape_nb_dispersion = context__.vals_r("prior_shape_nb_dispersion")[
          (1 - 1)];
      current_statement__ = 152;
      current_statement__ = 152;
      check_greater_or_equal(function__, "prior_shape_nb_dispersion",
                             prior_shape_nb_dispersion, 0);
      current_statement__ = 153;
      context__.validate_dims("data initialization",
          "prior_rate_nb_dispersion","double",context__.to_vec());
      prior_rate_nb_dispersion = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 153;
      prior_rate_nb_dispersion = context__.vals_r("prior_rate_nb_dispersion")[
          (1 - 1)];
      current_statement__ = 153;
      current_statement__ = 153;
      check_greater_or_equal(function__, "prior_rate_nb_dispersion",
                             prior_rate_nb_dispersion, 0);
      current_statement__ = 154;
      context__.validate_dims("data initialization","prior_scale_x0",
          "double",context__.to_vec());
      prior_scale_x0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 154;
      prior_scale_x0 = context__.vals_r("prior_scale_x0")[(1 - 1)];
      current_statement__ = 154;
      current_statement__ = 154;
      check_greater_or_equal(function__, "prior_scale_x0", prior_scale_x0, 0);
      current_statement__ = 155;
      context__.validate_dims("data initialization","prior_scale_x1",
          "double",context__.to_vec());
      prior_scale_x1 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 155;
      prior_scale_x1 = context__.vals_r("prior_scale_x1")[(1 - 1)];
      current_statement__ = 155;
      current_statement__ = 155;
      check_greater_or_equal(function__, "prior_scale_x1", prior_scale_x1, 0);
      current_statement__ = 156;
      context__.validate_dims("data initialization",
          "prior_scale_contactmatrix","double",context__.to_vec());
      prior_scale_contactmatrix = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 156;
      prior_scale_contactmatrix = context__.vals_r("prior_scale_contactmatrix")[
          (1 - 1)];
      current_statement__ = 156;
      current_statement__ = 156;
      check_greater_or_equal(function__, "prior_scale_contactmatrix",
                             prior_scale_contactmatrix, 0);
      current_statement__ = 157;
      context__.validate_dims("data initialization","prior_dist_pi","double",
          context__.to_vec(1, 2));
      prior_dist_pi = Eigen::Matrix<double, -1, -1>(1, 2);
      stan::math::fill(prior_dist_pi, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> prior_dist_pi_flat__;
        current_statement__ = 157;
        assign(prior_dist_pi_flat__, nil_index_list(),
          context__.vals_r("prior_dist_pi"),
          "assigning variable prior_dist_pi_flat__");
        current_statement__ = 157;
        pos__ = 1;
        current_statement__ = 157;
        for (int sym1__ = 1; sym1__ <= 2; ++sym1__) {
          current_statement__ = 157;
          for (int sym2__ = 1; sym2__ <= 1; ++sym2__) {
            current_statement__ = 157;
            assign(prior_dist_pi,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              prior_dist_pi_flat__[(pos__ - 1)],
              "assigning variable prior_dist_pi");
            current_statement__ = 157;
            pos__ = (pos__ + 1);}}
      }
      current_statement__ = 157;
      for (int sym1__ = 1; sym1__ <= 1; ++sym1__) {
        current_statement__ = 157;
        for (int sym2__ = 1; sym2__ <= 2; ++sym2__) {
          current_statement__ = 157;
          current_statement__ = 157;
          check_greater_or_equal(function__, "prior_dist_pi[sym1__, sym2__]",
                                 rvalue(prior_dist_pi,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "prior_dist_pi"),
                                 0);}}
      current_statement__ = 158;
      validate_non_negative_index("I_D_rev", "n_obs", n_obs);
      current_statement__ = 159;
      I_D_rev = Eigen::Matrix<double, -1, 1>(n_obs);
      stan::math::fill(I_D_rev, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 160;
      x_i = std::vector<int>(3, std::numeric_limits<int>::min());
      
      current_statement__ = 161;
      validate_non_negative_index("x_r", "2 * n_obs + A", ((2 * n_obs) + A));
      current_statement__ = 162;
      x_r = std::vector<double>(((2 * n_obs) + A), std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 163;
      gamma = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 164;
      tau = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 165;
      validate_non_negative_index("init", "A * n_difeq", (A * n_difeq));
      current_statement__ = 166;
      init = std::vector<double>((A * n_difeq), std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 166;
      assign(init, nil_index_list(), rep_array(0.0, (A * n_difeq)),
        "assigning variable init");
      current_statement__ = 167;
      validate_non_negative_index("ones_vector_A", "A", A);
      current_statement__ = 168;
      ones_vector_A = Eigen::Matrix<double, -1, 1>(A);
      stan::math::fill(ones_vector_A, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 168;
      assign(ones_vector_A, nil_index_list(), rep_vector(1.0, A),
        "assigning variable ones_vector_A");
      current_statement__ = 169;
      validate_non_negative_index("L_vector", "L_raw_length", L_raw_length);
      current_statement__ = 170;
      L_vector = Eigen::Matrix<double, -1, 1>(L_raw_length);
      stan::math::fill(L_vector, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 170;
      assign(L_vector, nil_index_list(), rep_vector(0, L_raw_length),
        "assigning variable L_vector");
      current_statement__ = 172;
      for (int t = 1; t <= n_obs; ++t) {
        current_statement__ = 171;
        assign(I_D_rev, cons_list(index_uni(t), nil_index_list()),
          I_D[(((n_obs - t) + 1) - 1)], "assigning variable I_D_rev");}
      current_statement__ = 173;
      assign(x_i, cons_list(index_uni(1), nil_index_list()), A,
        "assigning variable x_i");
      current_statement__ = 174;
      assign(x_i, cons_list(index_uni(2), nil_index_list()), n_obs,
        "assigning variable x_i");
      current_statement__ = 175;
      assign(x_i, cons_list(index_uni(3), nil_index_list()), n_difeq,
        "assigning variable x_i");
      current_statement__ = 176;
      assign(x_r, cons_list(index_min_max(1, n_obs), nil_index_list()),
        left_t, "assigning variable x_r");
      current_statement__ = 177;
      assign(x_r,
        cons_list(index_min_max((n_obs + 1), (2 * n_obs)), nil_index_list()),
        right_t, "assigning variable x_r");
      current_statement__ = 178;
      assign(x_r,
        cons_list(index_min_max(((2 * n_obs) + 1), ((2 * n_obs) + A)),
          nil_index_list()), age_dist, "assigning variable x_r");
      current_statement__ = 179;
      tau = (2.0 / incubation_period);
      current_statement__ = 180;
      gamma = (2.0 / infectious_period);
      current_statement__ = 159;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 159;
        current_statement__ = 159;
        check_greater_or_equal(function__, "I_D_rev[sym1__]",
                               I_D_rev[(sym1__ - 1)], 0);}
      current_statement__ = 163;
      current_statement__ = 163;
      check_greater_or_equal(function__, "gamma", gamma, 0);
      current_statement__ = 164;
      current_statement__ = 164;
      check_greater_or_equal(function__, "tau", tau, 0);
      current_statement__ = 181;
      validate_non_negative_index("x_init", "A", A);
      current_statement__ = 182;
      x_noise_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 182;
      x_noise_1dim__ = ((n_changes - 1) * A);
      current_statement__ = 182;
      validate_non_negative_index("x_noise", "(n_changes - 1) * A",
                                  x_noise_1dim__);
      current_statement__ = 183;
      validate_non_negative_index("volatilities", "A", A);
      current_statement__ = 184;
      validate_non_negative_index("L_raw", "L_raw_length", L_raw_length);
      current_statement__ = 185;
      validate_non_negative_index("x_trajectory", "n_changes", n_changes);
      current_statement__ = 186;
      validate_non_negative_index("x_trajectory", "A", A);
      current_statement__ = 187;
      validate_non_negative_index("beta_trajectory", "n_obs", n_obs);
      current_statement__ = 188;
      validate_non_negative_index("beta_trajectory", "A", A);
      current_statement__ = 189;
      beta_N_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 189;
      beta_N_1dim__ = (n_obs * A);
      current_statement__ = 189;
      validate_non_negative_index("beta_N", "n_obs * A", beta_N_1dim__);
      current_statement__ = 190;
      theta_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 190;
      theta_1dim__ = (((A * A) + (A * n_obs)) + 4);
      current_statement__ = 190;
      validate_non_negative_index("theta", "A * A + A * n_obs + 4",
                                  theta_1dim__);
      current_statement__ = 191;
      validate_non_negative_index("state_solutions", "n_obs", n_obs);
      current_statement__ = 192;
      state_solutions_2dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 192;
      state_solutions_2dim__ = (A * n_difeq);
      current_statement__ = 192;
      validate_non_negative_index("state_solutions", "A * n_difeq",
                                  state_solutions_2dim__);
      current_statement__ = 193;
      validate_non_negative_index("comp_C", "n_obs", n_obs);
      current_statement__ = 194;
      validate_non_negative_index("comp_C", "A", A);
      current_statement__ = 195;
      validate_non_negative_index("E_casesByAge", "n_obs", n_obs);
      current_statement__ = 196;
      validate_non_negative_index("E_casesByAge", "A", A);
      current_statement__ = 197;
      validate_non_negative_index("E_deathsByAge", "n_obs", n_obs);
      current_statement__ = 198;
      validate_non_negative_index("E_deathsByAge", "A", A);
      current_statement__ = 199;
      validate_non_negative_index("cm_sym", "A", A);
      current_statement__ = 200;
      validate_non_negative_index("cm_sym", "A", A);
      current_statement__ = 201;
      validate_non_negative_index("cm_sample", "A", A);
      current_statement__ = 202;
      validate_non_negative_index("cm_sample", "A", A);
      current_statement__ = 203;
      validate_non_negative_index("L_raw_mat", "A", A);
      current_statement__ = 204;
      validate_non_negative_index("L_raw_mat", "A", A);
      current_statement__ = 205;
      validate_non_negative_index("L", "A", A);
      current_statement__ = 206;
      validate_non_negative_index("L", "A", A);
      current_statement__ = 207;
      x_noise_mat_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 207;
      x_noise_mat_1dim__ = (n_changes - 1);
      current_statement__ = 207;
      validate_non_negative_index("x_noise_mat", "n_changes - 1",
                                  x_noise_mat_1dim__);
      current_statement__ = 208;
      validate_non_negative_index("x_noise_mat", "A", A);
      current_statement__ = 209;
      validate_non_negative_index("E_cases", "n_obs", n_obs);
      current_statement__ = 210;
      validate_non_negative_index("E_deaths", "n_obs", n_obs);
      current_statement__ = 211;
      validate_non_negative_index("Susceptibles", "n_obs", n_obs);
      current_statement__ = 212;
      validate_non_negative_index("Susceptibles", "A", A);
      current_statement__ = 213;
      validate_non_negative_index("log_like_age", "n_obs", n_obs);
      current_statement__ = 214;
      validate_non_negative_index("log_like_age", "A", A);
      current_statement__ = 215;
      validate_non_negative_index("log_lik", "n_obs", n_obs);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = 0U;
    
    try {
      num_params_r__ += 1;
      num_params_r__ += A;
      num_params_r__ += x_noise_1dim__;
      num_params_r__ += 1;
      num_params_r__ += A;
      num_params_r__ += 1;
      num_params_r__ += L_raw_length;
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
  }
  template <bool propto__, bool jacobian__, typename VecR, typename VecI, stan::require_vector_like_t<VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    static const char* function__ = "model_igbm_namespace::log_prob";
(void) function__;  // suppress unused var warning
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      local_scalar_t__ x0;
      x0 = DUMMY_VAR__;
      
      current_statement__ = 1;
      x0 = in__.scalar();
      std::vector<local_scalar_t__> x_init;
      x_init = std::vector<local_scalar_t__>(A, DUMMY_VAR__);
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        current_statement__ = 2;
        assign(x_init, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable x_init");}
      std::vector<local_scalar_t__> x_noise;
      x_noise = std::vector<local_scalar_t__>(x_noise_1dim__, DUMMY_VAR__);
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= x_noise_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(x_noise, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable x_noise");}
      local_scalar_t__ pi;
      pi = DUMMY_VAR__;
      
      current_statement__ = 4;
      pi = in__.scalar();
      current_statement__ = 4;
      if (jacobian__) {
        current_statement__ = 4;
        pi = stan::math::lub_constrain(pi, 0, 1, lp__);
      } else {
        current_statement__ = 4;
        pi = stan::math::lub_constrain(pi, 0, 1);
      }
      std::vector<local_scalar_t__> volatilities;
      volatilities = std::vector<local_scalar_t__>(A, DUMMY_VAR__);
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        current_statement__ = 5;
        assign(volatilities, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable volatilities");}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        current_statement__ = 5;
        if (jacobian__) {
          current_statement__ = 5;
          assign(volatilities,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(volatilities[(sym1__ - 1)], 0, lp__),
            "assigning variable volatilities");
        } else {
          current_statement__ = 5;
          assign(volatilities,
            cons_list(index_uni(sym1__), nil_index_list()),
            stan::math::lb_constrain(volatilities[(sym1__ - 1)], 0),
            "assigning variable volatilities");
        }}
      local_scalar_t__ phiD;
      phiD = DUMMY_VAR__;
      
      current_statement__ = 6;
      phiD = in__.scalar();
      current_statement__ = 6;
      if (jacobian__) {
        current_statement__ = 6;
        phiD = stan::math::lb_constrain(phiD, 0, lp__);
      } else {
        current_statement__ = 6;
        phiD = stan::math::lb_constrain(phiD, 0);
      }
      Eigen::Matrix<local_scalar_t__, -1, 1> L_raw;
      L_raw = Eigen::Matrix<local_scalar_t__, -1, 1>(L_raw_length);
      stan::math::fill(L_raw, DUMMY_VAR__);
      
      current_statement__ = 7;
      L_raw = in__.vector(L_raw_length);
      Eigen::Matrix<local_scalar_t__, -1, -1> x_trajectory;
      x_trajectory = Eigen::Matrix<local_scalar_t__, -1, -1>(n_changes, A);
      stan::math::fill(x_trajectory, DUMMY_VAR__);
      
      local_scalar_t__ beta0;
      beta0 = DUMMY_VAR__;
      
      Eigen::Matrix<local_scalar_t__, -1, -1> beta_trajectory;
      beta_trajectory = Eigen::Matrix<local_scalar_t__, -1, -1>(n_obs, A);
      stan::math::fill(beta_trajectory, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> beta_N;
      beta_N = std::vector<local_scalar_t__>(beta_N_1dim__, DUMMY_VAR__);
      
      std::vector<local_scalar_t__> theta;
      theta = std::vector<local_scalar_t__>(theta_1dim__, DUMMY_VAR__);
      
      std::vector<std::vector<local_scalar_t__>> state_solutions;
      state_solutions = std::vector<std::vector<local_scalar_t__>>(n_obs, std::vector<local_scalar_t__>(state_solutions_2dim__, DUMMY_VAR__));
      
      Eigen::Matrix<local_scalar_t__, -1, -1> comp_C;
      comp_C = Eigen::Matrix<local_scalar_t__, -1, -1>(n_obs, A);
      stan::math::fill(comp_C, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> E_casesByAge;
      E_casesByAge = Eigen::Matrix<local_scalar_t__, -1, -1>(n_obs, A);
      stan::math::fill(E_casesByAge, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> E_deathsByAge;
      E_deathsByAge = Eigen::Matrix<local_scalar_t__, -1, -1>(n_obs, A);
      stan::math::fill(E_deathsByAge, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> cm_sym;
      cm_sym = Eigen::Matrix<local_scalar_t__, -1, -1>(A, A);
      stan::math::fill(cm_sym, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> cm_sample;
      cm_sample = Eigen::Matrix<local_scalar_t__, -1, -1>(A, A);
      stan::math::fill(cm_sample, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> L_raw_mat;
      L_raw_mat = Eigen::Matrix<local_scalar_t__, -1, -1>(A, A);
      stan::math::fill(L_raw_mat, DUMMY_VAR__);
      
      current_statement__ = 19;
      assign(L_raw_mat, nil_index_list(), to_triangular(L_raw, A, pstream__),
        "assigning variable L_raw_mat");
      Eigen::Matrix<local_scalar_t__, -1, -1> L;
      L = Eigen::Matrix<local_scalar_t__, -1, -1>(A, A);
      stan::math::fill(L, DUMMY_VAR__);
      
      current_statement__ = 20;
      assign(L, nil_index_list(), to_triangular(L_vector, A, pstream__),
        "assigning variable L");
      Eigen::Matrix<local_scalar_t__, -1, -1> x_noise_mat;
      x_noise_mat = Eigen::Matrix<local_scalar_t__, -1, -1>(x_noise_mat_1dim__, A);
      stan::math::fill(x_noise_mat, DUMMY_VAR__);
      
      current_statement__ = 21;
      assign(x_noise_mat, nil_index_list(),
        to_matrix(x_noise, (n_changes - 1), A),
        "assigning variable x_noise_mat");
      current_statement__ = 24;
      for (int col = 1; col <= A; ++col) {
        current_statement__ = 23;
        for (int row = col; row <= A; ++row) {
          current_statement__ = 22;
          assign(L,
            cons_list(index_uni(row),
              cons_list(index_uni(col), nil_index_list())),
            (L_cm[(row - 1)][(col - 1)] +
              ((prior_scale_contactmatrix * L_cm[(row - 1)][(col - 1)]) *
                rvalue(L_raw_mat,
                  cons_list(index_uni(row),
                    cons_list(index_uni(col), nil_index_list())),
                  "L_raw_mat"))), "assigning variable L");}}
      current_statement__ = 25;
      assign(cm_sym, nil_index_list(), tcrossprod(L),
        "assigning variable cm_sym");
      current_statement__ = 26;
      assign(cm_sample, nil_index_list(),
        diag_pre_multiply(pop_diag, cm_sym), "assigning variable cm_sample");
      current_statement__ = 27;
      assign(x_trajectory,
        cons_list(index_uni(1), cons_list(index_omni(), nil_index_list())),
        to_row_vector(x_init), "assigning variable x_trajectory");
      current_statement__ = 30;
      for (int t = 2; t <= n_changes; ++t) {
        current_statement__ = 29;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 28;
          assign(x_trajectory,
            cons_list(index_uni(t),
              cons_list(index_uni(j), nil_index_list())),
            (rvalue(x_trajectory,
               cons_list(index_uni((t - 1)),
                 cons_list(index_uni(j), nil_index_list())), "x_trajectory")
              +
              (volatilities[(j - 1)] *
                rvalue(x_noise_mat,
                  cons_list(index_uni((t - 1)),
                    cons_list(index_uni(j), nil_index_list())),
                  "x_noise_mat"))), "assigning variable x_trajectory");}}
      current_statement__ = 31;
      beta0 = stan::math::exp(x0);
      current_statement__ = 36;
      if (logical_eq(ecr_changes, 1)) {
        current_statement__ = 34;
        assign(beta_trajectory, nil_index_list(),
          stan::math::exp(x_trajectory), "assigning variable beta_trajectory");
      } else {
        current_statement__ = 32;
        assign(beta_trajectory, nil_index_list(),
          append_row(
            repeat_matrix(
              stan::math::exp(
                rvalue(x_trajectory,
                  cons_list(index_min_max(1, (n_changes - 1)),
                    cons_list(index_omni(), nil_index_list())),
                  "x_trajectory")), ecr_changes, pstream__),
            repeat_rv_to_matrix(
              stan::math::exp(
                rvalue(x_trajectory,
                  cons_list(index_uni(n_changes), nil_index_list()),
                  "x_trajectory")), n_remainder, pstream__)),
          "assigning variable beta_trajectory");
      }
      current_statement__ = 37;
      assign(beta_N, nil_index_list(),
        to_vector_colwise(beta_trajectory, pstream__),
        "assigning variable beta_N");
      current_statement__ = 38;
      assign(theta, cons_list(index_min_max(1, (A * A)), nil_index_list()),
        to_vector_rowwise(cm_sample, pstream__), "assigning variable theta");
      current_statement__ = 39;
      assign(theta, cons_list(index_uni(((A * A) + 1)), nil_index_list()),
        gamma, "assigning variable theta");
      current_statement__ = 40;
      assign(theta, cons_list(index_uni(((A * A) + 2)), nil_index_list()),
        beta0, "assigning variable theta");
      current_statement__ = 41;
      assign(theta,
        cons_list(
          index_min_max(((A * A) + 3), (((A * A) + (A * n_obs)) + 2)),
          nil_index_list()), beta_N, "assigning variable theta");
      current_statement__ = 42;
      assign(theta,
        cons_list(index_uni((((A * n_obs) + (A * A)) + 3)), nil_index_list()),
        pi, "assigning variable theta");
      current_statement__ = 43;
      assign(theta,
        cons_list(index_uni((((A * n_obs) + (A * A)) + 4)), nil_index_list()),
        tau, "assigning variable theta");
      current_statement__ = 44;
      assign(state_solutions, nil_index_list(),
        integrate_ode_trapezoidal(init, t0, ts, theta, x_r, x_i, pstream__),
        "assigning variable state_solutions");
      current_statement__ = 54;
      for (int t = 1; t <= n_obs; ++t) {
        current_statement__ = 46;
        if (logical_eq(t, 1)) {
          current_statement__ = 45;
          assign(E_deathsByAge,
            cons_list(index_uni(t),
              cons_list(index_omni(), nil_index_list())), E_deathsByAge_day1,
            "assigning variable E_deathsByAge");
        } 
        current_statement__ = 52;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 47;
          assign(comp_C,
            cons_list(index_uni(t),
              cons_list(index_uni(j), nil_index_list())),
            (state_solutions[(t - 1)][((((n_difeq - 1) * A) + j) - 1)] *
              n_pop), "assigning variable comp_C");
          current_statement__ = 48;
          assign(E_casesByAge,
            cons_list(index_uni(t),
              cons_list(index_uni(j), nil_index_list())),
            (rvalue(comp_C,
               cons_list(index_uni(t),
                 cons_list(index_uni(j), nil_index_list())), "comp_C") -
              (logical_eq(t, 1) ?
                 stan::math::promote_scalar<local_scalar_t__>(0) :
                 stan::math::promote_scalar<local_scalar_t__>((
                                                                 logical_gt(
                                                                   rvalue(
                                                                    comp_C,
                                                                    cons_list(
                                                                    index_uni(t),
                                                                    cons_list(
                                                                    index_uni(j),
                                                                    nil_index_list())),
                                                                    "comp_C"),
                                                                   rvalue(
                                                                    comp_C,
                                                                    cons_list(
                                                                    index_uni(
                                                                    (t - 1)),
                                                                    cons_list(
                                                                    index_uni(j),
                                                                    nil_index_list())),
                                                                    "comp_C"))
                                                                 ?
                                                                 stan::math::promote_scalar<local_scalar_t__>(
                                                                 rvalue(
                                                                   comp_C,
                                                                   cons_list(
                                                                    index_uni(
                                                                    (t - 1)),
                                                                    cons_list(
                                                                    index_uni(j),
                                                                    nil_index_list())),
                                                                   "comp_C"))
                                                                 :
                                                                 stan::math::promote_scalar<local_scalar_t__>(0))))),
            "assigning variable E_casesByAge");
          current_statement__ = 50;
          if (logical_neq(t, 1)) {
            current_statement__ = 49;
            assign(E_deathsByAge,
              cons_list(index_uni(t),
                cons_list(index_uni(j), nil_index_list())),
              (age_specific_ifr[(t - 1)][(j - 1)] *
                dot_product(
                  head(
                    rvalue(E_casesByAge,
                      cons_list(index_omni(),
                        cons_list(index_uni(j), nil_index_list())),
                      "E_casesByAge"), (t - 1)), tail(I_D_rev, (t - 1)))),
              "assigning variable E_deathsByAge");
          } }}
      current_statement__ = 9;
      current_statement__ = 9;
      check_greater_or_equal(function__, "beta0", beta0, 0);
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 10;
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          current_statement__ = 10;
          current_statement__ = 10;
          check_greater_or_equal(function__,
                                 "beta_trajectory[sym1__, sym2__]",
                                 rvalue(beta_trajectory,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "beta_trajectory"),
                                 0);}}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= beta_N_1dim__; ++sym1__) {
        current_statement__ = 11;
        current_statement__ = 11;
        check_greater_or_equal(function__, "beta_N[sym1__]",
                               beta_N[(sym1__ - 1)], 0);}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__, "E_casesByAge[sym1__, sym2__]",
                                 rvalue(E_casesByAge,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "E_casesByAge"), 0);
        }}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_greater_or_equal(function__, "E_deathsByAge[sym1__, sym2__]",
                                 rvalue(E_deathsByAge,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "E_deathsByAge"),
                                 0);}}
      {
        current_statement__ = 74;
        lp_accum__.add(
          beta_lpdf<propto__>(pi,
            rvalue(prior_dist_pi,
              cons_list(index_uni(1),
                cons_list(index_uni(1), nil_index_list())), "prior_dist_pi"),
            rvalue(prior_dist_pi,
              cons_list(index_uni(1),
                cons_list(index_uni(2), nil_index_list())), "prior_dist_pi")));
        current_statement__ = 75;
        lp_accum__.add(normal_lpdf<propto__>(x0, 0, prior_scale_x0));
        current_statement__ = 76;
        lp_accum__.add(normal_lpdf<propto__>(x_init, 0, prior_scale_x1));
        current_statement__ = 77;
        lp_accum__.add(std_normal_lpdf<propto__>(x_noise));
        current_statement__ = 78;
        lp_accum__.add(std_normal_lpdf<propto__>(L_raw));
        current_statement__ = 88;
        if (logical_eq(prior_dist_volatility, 1)) {
          current_statement__ = 87;
          lp_accum__.add(
            normal_lpdf<propto__>(volatilities, prior_mean_volatility,
              prior_scale_volatility));
        } else {
          current_statement__ = 86;
          if (logical_eq(prior_dist_volatility, 2)) {
            current_statement__ = 85;
            lp_accum__.add(
              cauchy_lpdf<propto__>(volatilities, prior_mean_volatility,
                prior_scale_volatility));
          } else {
            current_statement__ = 84;
            if (logical_eq(prior_dist_volatility, 3)) {
              current_statement__ = 83;
              lp_accum__.add(
                student_t_lpdf<propto__>(volatilities, prior_df_volatility,
                  prior_mean_volatility, prior_scale_volatility));
            } else {
              current_statement__ = 82;
              if (logical_eq(prior_dist_volatility, 4)) {
                current_statement__ = 81;
                lp_accum__.add(
                  gamma_lpdf<propto__>(volatilities, prior_shape_volatility,
                    prior_rate_volatility));
              } else {
                current_statement__ = 80;
                if (logical_eq(prior_dist_volatility, 5)) {
                  current_statement__ = 79;
                  lp_accum__.add(
                    exponential_lpdf<propto__>(volatilities,
                      prior_rate_volatility));
                } 
              }
            }
          }
        }
        current_statement__ = 98;
        if (logical_eq(prior_dist_nb_dispersion, 1)) {
          current_statement__ = 97;
          lp_accum__.add(
            normal_lpdf<propto__>(phiD, prior_mean_nb_dispersion,
              prior_scale_nb_dispersion));
        } else {
          current_statement__ = 96;
          if (logical_eq(prior_dist_nb_dispersion, 2)) {
            current_statement__ = 95;
            lp_accum__.add(
              cauchy_lpdf<propto__>(phiD, prior_mean_nb_dispersion,
                prior_scale_nb_dispersion));
          } else {
            current_statement__ = 94;
            if (logical_eq(prior_dist_nb_dispersion, 3)) {
              current_statement__ = 93;
              lp_accum__.add(
                student_t_lpdf<propto__>(phiD, prior_df_nb_dispersion,
                  prior_mean_nb_dispersion, prior_scale_nb_dispersion));
            } else {
              current_statement__ = 92;
              if (logical_eq(prior_dist_nb_dispersion, 4)) {
                current_statement__ = 91;
                lp_accum__.add(
                  gamma_lpdf<propto__>(phiD, prior_shape_nb_dispersion,
                    prior_rate_nb_dispersion));
              } else {
                current_statement__ = 90;
                if (logical_eq(prior_dist_nb_dispersion, 5)) {
                  current_statement__ = 89;
                  lp_accum__.add(
                    exponential_lpdf<propto__>(phiD,
                      prior_rate_nb_dispersion));
                } 
              }
            }
          }
        }
        current_statement__ = 106;
        for (int i = 1; i <= n_obs; ++i) {
          current_statement__ = 104;
          for (int j = 1; j <= A; ++j) {
            current_statement__ = 102;
            if (logical_eq(likelihood_variance_type, 0)) {
              current_statement__ = 101;
              lp_accum__.add(
                neg_binomial_2_lpmf<false>(y_data[(i - 1)][(j - 1)],
                  rvalue(E_deathsByAge,
                    cons_list(index_uni(i),
                      cons_list(index_uni(j), nil_index_list())),
                    "E_deathsByAge"), phiD));
            } else {
              current_statement__ = 100;
              if (logical_eq(likelihood_variance_type, 1)) {
                current_statement__ = 99;
                lp_accum__.add(
                  neg_binomial_2_lpmf<false>(y_data[(i - 1)][(j - 1)],
                    rvalue(E_deathsByAge,
                      cons_list(index_uni(i),
                        cons_list(index_uni(j), nil_index_list())),
                      "E_deathsByAge"),
                    (rvalue(E_deathsByAge,
                       cons_list(index_uni(i),
                         cons_list(index_uni(j), nil_index_list())),
                       "E_deathsByAge") / phiD)));
              } 
            }}}
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr>
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
    static const char* function__ = "model_igbm_namespace::write_array";
(void) function__;  // suppress unused var warning
    (void) function__;  // suppress unused var warning
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    
    try {
      double x0;
      x0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      x0 = in__.scalar();
      std::vector<double> x_init;
      x_init = std::vector<double>(A, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        current_statement__ = 2;
        assign(x_init, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable x_init");}
      std::vector<double> x_noise;
      x_noise = std::vector<double>(x_noise_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      for (int sym1__ = 1; sym1__ <= x_noise_1dim__; ++sym1__) {
        current_statement__ = 3;
        assign(x_noise, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable x_noise");}
      double pi;
      pi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      pi = in__.scalar();
      current_statement__ = 4;
      pi = stan::math::lub_constrain(pi, 0, 1);
      std::vector<double> volatilities;
      volatilities = std::vector<double>(A, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        current_statement__ = 5;
        assign(volatilities, cons_list(index_uni(sym1__), nil_index_list()),
          in__.scalar(), "assigning variable volatilities");}
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        current_statement__ = 5;
        assign(volatilities, cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_constrain(volatilities[(sym1__ - 1)], 0),
          "assigning variable volatilities");}
      double phiD;
      phiD = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      phiD = in__.scalar();
      current_statement__ = 6;
      phiD = stan::math::lb_constrain(phiD, 0);
      Eigen::Matrix<double, -1, 1> L_raw;
      L_raw = Eigen::Matrix<double, -1, 1>(L_raw_length);
      stan::math::fill(L_raw, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 7;
      L_raw = in__.vector(L_raw_length);
      Eigen::Matrix<double, -1, -1> x_trajectory;
      x_trajectory = Eigen::Matrix<double, -1, -1>(n_changes, A);
      stan::math::fill(x_trajectory, std::numeric_limits<double>::quiet_NaN());
      
      double beta0;
      beta0 = std::numeric_limits<double>::quiet_NaN();
      
      Eigen::Matrix<double, -1, -1> beta_trajectory;
      beta_trajectory = Eigen::Matrix<double, -1, -1>(n_obs, A);
      stan::math::fill(beta_trajectory, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> beta_N;
      beta_N = std::vector<double>(beta_N_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<double> theta;
      theta = std::vector<double>(theta_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      std::vector<std::vector<double>> state_solutions;
      state_solutions = std::vector<std::vector<double>>(n_obs, std::vector<double>(state_solutions_2dim__, std::numeric_limits<double>::quiet_NaN()));
      
      Eigen::Matrix<double, -1, -1> comp_C;
      comp_C = Eigen::Matrix<double, -1, -1>(n_obs, A);
      stan::math::fill(comp_C, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> E_casesByAge;
      E_casesByAge = Eigen::Matrix<double, -1, -1>(n_obs, A);
      stan::math::fill(E_casesByAge, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> E_deathsByAge;
      E_deathsByAge = Eigen::Matrix<double, -1, -1>(n_obs, A);
      stan::math::fill(E_deathsByAge, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> cm_sym;
      cm_sym = Eigen::Matrix<double, -1, -1>(A, A);
      stan::math::fill(cm_sym, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> cm_sample;
      cm_sample = Eigen::Matrix<double, -1, -1>(A, A);
      stan::math::fill(cm_sample, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> L_raw_mat;
      L_raw_mat = Eigen::Matrix<double, -1, -1>(A, A);
      stan::math::fill(L_raw_mat, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> L;
      L = Eigen::Matrix<double, -1, -1>(A, A);
      stan::math::fill(L, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> x_noise_mat;
      x_noise_mat = Eigen::Matrix<double, -1, -1>(x_noise_mat_1dim__, A);
      stan::math::fill(x_noise_mat, std::numeric_limits<double>::quiet_NaN());
      
      vars__.emplace_back(x0);
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        vars__.emplace_back(x_init[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= x_noise_1dim__; ++sym1__) {
        vars__.emplace_back(x_noise[(sym1__ - 1)]);}
      vars__.emplace_back(pi);
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        vars__.emplace_back(volatilities[(sym1__ - 1)]);}
      vars__.emplace_back(phiD);
      for (int sym1__ = 1; sym1__ <= L_raw_length; ++sym1__) {
        vars__.emplace_back(L_raw[(sym1__ - 1)]);}
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 19;
      assign(L_raw_mat, nil_index_list(), to_triangular(L_raw, A, pstream__),
        "assigning variable L_raw_mat");
      current_statement__ = 20;
      assign(L, nil_index_list(), to_triangular(L_vector, A, pstream__),
        "assigning variable L");
      current_statement__ = 21;
      assign(x_noise_mat, nil_index_list(),
        to_matrix(x_noise, (n_changes - 1), A),
        "assigning variable x_noise_mat");
      current_statement__ = 24;
      for (int col = 1; col <= A; ++col) {
        current_statement__ = 23;
        for (int row = col; row <= A; ++row) {
          current_statement__ = 22;
          assign(L,
            cons_list(index_uni(row),
              cons_list(index_uni(col), nil_index_list())),
            (L_cm[(row - 1)][(col - 1)] +
              ((prior_scale_contactmatrix * L_cm[(row - 1)][(col - 1)]) *
                rvalue(L_raw_mat,
                  cons_list(index_uni(row),
                    cons_list(index_uni(col), nil_index_list())),
                  "L_raw_mat"))), "assigning variable L");}}
      current_statement__ = 25;
      assign(cm_sym, nil_index_list(), tcrossprod(L),
        "assigning variable cm_sym");
      current_statement__ = 26;
      assign(cm_sample, nil_index_list(),
        diag_pre_multiply(pop_diag, cm_sym), "assigning variable cm_sample");
      current_statement__ = 27;
      assign(x_trajectory,
        cons_list(index_uni(1), cons_list(index_omni(), nil_index_list())),
        to_row_vector(x_init), "assigning variable x_trajectory");
      current_statement__ = 30;
      for (int t = 2; t <= n_changes; ++t) {
        current_statement__ = 29;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 28;
          assign(x_trajectory,
            cons_list(index_uni(t),
              cons_list(index_uni(j), nil_index_list())),
            (rvalue(x_trajectory,
               cons_list(index_uni((t - 1)),
                 cons_list(index_uni(j), nil_index_list())), "x_trajectory")
              +
              (volatilities[(j - 1)] *
                rvalue(x_noise_mat,
                  cons_list(index_uni((t - 1)),
                    cons_list(index_uni(j), nil_index_list())),
                  "x_noise_mat"))), "assigning variable x_trajectory");}}
      current_statement__ = 31;
      beta0 = stan::math::exp(x0);
      current_statement__ = 36;
      if (logical_eq(ecr_changes, 1)) {
        current_statement__ = 34;
        assign(beta_trajectory, nil_index_list(),
          stan::math::exp(x_trajectory), "assigning variable beta_trajectory");
      } else {
        current_statement__ = 32;
        assign(beta_trajectory, nil_index_list(),
          append_row(
            repeat_matrix(
              stan::math::exp(
                rvalue(x_trajectory,
                  cons_list(index_min_max(1, (n_changes - 1)),
                    cons_list(index_omni(), nil_index_list())),
                  "x_trajectory")), ecr_changes, pstream__),
            repeat_rv_to_matrix(
              stan::math::exp(
                rvalue(x_trajectory,
                  cons_list(index_uni(n_changes), nil_index_list()),
                  "x_trajectory")), n_remainder, pstream__)),
          "assigning variable beta_trajectory");
      }
      current_statement__ = 37;
      assign(beta_N, nil_index_list(),
        to_vector_colwise(beta_trajectory, pstream__),
        "assigning variable beta_N");
      current_statement__ = 38;
      assign(theta, cons_list(index_min_max(1, (A * A)), nil_index_list()),
        to_vector_rowwise(cm_sample, pstream__), "assigning variable theta");
      current_statement__ = 39;
      assign(theta, cons_list(index_uni(((A * A) + 1)), nil_index_list()),
        gamma, "assigning variable theta");
      current_statement__ = 40;
      assign(theta, cons_list(index_uni(((A * A) + 2)), nil_index_list()),
        beta0, "assigning variable theta");
      current_statement__ = 41;
      assign(theta,
        cons_list(
          index_min_max(((A * A) + 3), (((A * A) + (A * n_obs)) + 2)),
          nil_index_list()), beta_N, "assigning variable theta");
      current_statement__ = 42;
      assign(theta,
        cons_list(index_uni((((A * n_obs) + (A * A)) + 3)), nil_index_list()),
        pi, "assigning variable theta");
      current_statement__ = 43;
      assign(theta,
        cons_list(index_uni((((A * n_obs) + (A * A)) + 4)), nil_index_list()),
        tau, "assigning variable theta");
      current_statement__ = 44;
      assign(state_solutions, nil_index_list(),
        integrate_ode_trapezoidal(init, t0, ts, theta, x_r, x_i, pstream__),
        "assigning variable state_solutions");
      current_statement__ = 54;
      for (int t = 1; t <= n_obs; ++t) {
        current_statement__ = 46;
        if (logical_eq(t, 1)) {
          current_statement__ = 45;
          assign(E_deathsByAge,
            cons_list(index_uni(t),
              cons_list(index_omni(), nil_index_list())), E_deathsByAge_day1,
            "assigning variable E_deathsByAge");
        } 
        current_statement__ = 52;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 47;
          assign(comp_C,
            cons_list(index_uni(t),
              cons_list(index_uni(j), nil_index_list())),
            (state_solutions[(t - 1)][((((n_difeq - 1) * A) + j) - 1)] *
              n_pop), "assigning variable comp_C");
          current_statement__ = 48;
          assign(E_casesByAge,
            cons_list(index_uni(t),
              cons_list(index_uni(j), nil_index_list())),
            (rvalue(comp_C,
               cons_list(index_uni(t),
                 cons_list(index_uni(j), nil_index_list())), "comp_C") -
              (logical_eq(t, 1) ?
                 stan::math::promote_scalar<local_scalar_t__>(0) :
                 stan::math::promote_scalar<local_scalar_t__>((
                                                                 logical_gt(
                                                                   rvalue(
                                                                    comp_C,
                                                                    cons_list(
                                                                    index_uni(t),
                                                                    cons_list(
                                                                    index_uni(j),
                                                                    nil_index_list())),
                                                                    "comp_C"),
                                                                   rvalue(
                                                                    comp_C,
                                                                    cons_list(
                                                                    index_uni(
                                                                    (t - 1)),
                                                                    cons_list(
                                                                    index_uni(j),
                                                                    nil_index_list())),
                                                                    "comp_C"))
                                                                 ?
                                                                 stan::math::promote_scalar<local_scalar_t__>(
                                                                 rvalue(
                                                                   comp_C,
                                                                   cons_list(
                                                                    index_uni(
                                                                    (t - 1)),
                                                                    cons_list(
                                                                    index_uni(j),
                                                                    nil_index_list())),
                                                                   "comp_C"))
                                                                 :
                                                                 stan::math::promote_scalar<local_scalar_t__>(0))))),
            "assigning variable E_casesByAge");
          current_statement__ = 50;
          if (logical_neq(t, 1)) {
            current_statement__ = 49;
            assign(E_deathsByAge,
              cons_list(index_uni(t),
                cons_list(index_uni(j), nil_index_list())),
              (age_specific_ifr[(t - 1)][(j - 1)] *
                dot_product(
                  head(
                    rvalue(E_casesByAge,
                      cons_list(index_omni(),
                        cons_list(index_uni(j), nil_index_list())),
                      "E_casesByAge"), (t - 1)), tail(I_D_rev, (t - 1)))),
              "assigning variable E_deathsByAge");
          } }}
      current_statement__ = 9;
      current_statement__ = 9;
      check_greater_or_equal(function__, "beta0", beta0, 0);
      current_statement__ = 10;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 10;
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          current_statement__ = 10;
          current_statement__ = 10;
          check_greater_or_equal(function__,
                                 "beta_trajectory[sym1__, sym2__]",
                                 rvalue(beta_trajectory,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "beta_trajectory"),
                                 0);}}
      current_statement__ = 11;
      for (int sym1__ = 1; sym1__ <= beta_N_1dim__; ++sym1__) {
        current_statement__ = 11;
        current_statement__ = 11;
        check_greater_or_equal(function__, "beta_N[sym1__]",
                               beta_N[(sym1__ - 1)], 0);}
      current_statement__ = 15;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 15;
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          current_statement__ = 15;
          current_statement__ = 15;
          check_greater_or_equal(function__, "E_casesByAge[sym1__, sym2__]",
                                 rvalue(E_casesByAge,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "E_casesByAge"), 0);
        }}
      current_statement__ = 16;
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        current_statement__ = 16;
        for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
          current_statement__ = 16;
          current_statement__ = 16;
          check_greater_or_equal(function__, "E_deathsByAge[sym1__, sym2__]",
                                 rvalue(E_deathsByAge,
                                   cons_list(index_uni(sym1__),
                                     cons_list(index_uni(sym2__),
                                       nil_index_list())), "E_deathsByAge"),
                                 0);}}
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n_changes; ++sym2__) {
            vars__.emplace_back(
              rvalue(x_trajectory,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "x_trajectory"));}}
        vars__.emplace_back(beta0);
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            vars__.emplace_back(
              rvalue(beta_trajectory,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "beta_trajectory"));}}
        for (int sym1__ = 1; sym1__ <= beta_N_1dim__; ++sym1__) {
          vars__.emplace_back(beta_N[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= theta_1dim__; ++sym1__) {
          vars__.emplace_back(theta[(sym1__ - 1)]);}
        for (int sym1__ = 1; sym1__ <= state_solutions_2dim__; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            vars__.emplace_back(state_solutions[(sym2__ - 1)][(sym1__ - 1)]);
          }}
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            vars__.emplace_back(
              rvalue(comp_C,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "comp_C"));
          }}
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            vars__.emplace_back(
              rvalue(E_casesByAge,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "E_casesByAge"));}}
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            vars__.emplace_back(
              rvalue(E_deathsByAge,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "E_deathsByAge"));}}
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            vars__.emplace_back(
              rvalue(cm_sym,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "cm_sym"));
          }}
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            vars__.emplace_back(
              rvalue(cm_sample,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "cm_sample"));}}
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            vars__.emplace_back(
              rvalue(L_raw_mat,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "L_raw_mat"));}}
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            vars__.emplace_back(
              rvalue(L,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())), "L"));}}
        for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= x_noise_mat_1dim__; ++sym2__) {
            vars__.emplace_back(
              rvalue(x_noise_mat,
                cons_list(index_uni(sym2__),
                  cons_list(index_uni(sym1__), nil_index_list())),
                "x_noise_mat"));}}
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
      Eigen::Matrix<double, -1, 1> E_cases;
      E_cases = Eigen::Matrix<double, -1, 1>(n_obs);
      stan::math::fill(E_cases, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> E_deaths;
      E_deaths = Eigen::Matrix<double, -1, 1>(n_obs);
      stan::math::fill(E_deaths, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> Susceptibles;
      Susceptibles = Eigen::Matrix<double, -1, -1>(n_obs, A);
      stan::math::fill(Susceptibles, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, -1> log_like_age;
      log_like_age = Eigen::Matrix<double, -1, -1>(n_obs, A);
      stan::math::fill(log_like_age, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> log_lik;
      log_lik = Eigen::Matrix<double, -1, 1>(n_obs);
      stan::math::fill(log_lik, std::numeric_limits<double>::quiet_NaN());
      
      double deviance;
      deviance = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 61;
      assign(E_cases, nil_index_list(),
        multiply(E_casesByAge, ones_vector_A), "assigning variable E_cases");
      current_statement__ = 62;
      assign(E_deaths, nil_index_list(),
        multiply(E_deathsByAge, ones_vector_A), "assigning variable E_deaths");
      current_statement__ = 72;
      for (int t = 1; t <= n_obs; ++t) {
        current_statement__ = 69;
        for (int j = 1; j <= A; ++j) {
          current_statement__ = 63;
          assign(Susceptibles,
            cons_list(index_uni(t),
              cons_list(index_uni(j), nil_index_list())),
            ((state_solutions[(t - 1)][(j - 1)] +
               (age_dist[(j - 1)] * (1 - pi))) * n_pop),
            "assigning variable Susceptibles");
          current_statement__ = 67;
          if (logical_eq(likelihood_variance_type, 0)) {
            current_statement__ = 66;
            assign(log_like_age,
              cons_list(index_uni(t),
                cons_list(index_uni(j), nil_index_list())),
              neg_binomial_2_lpmf<false>(y_data[(t - 1)][(j - 1)],
                rvalue(E_deathsByAge,
                  cons_list(index_uni(t),
                    cons_list(index_uni(j), nil_index_list())),
                  "E_deathsByAge"), phiD), "assigning variable log_like_age");
          } else {
            current_statement__ = 65;
            if (logical_eq(likelihood_variance_type, 1)) {
              current_statement__ = 64;
              assign(log_like_age,
                cons_list(index_uni(t),
                  cons_list(index_uni(j), nil_index_list())),
                neg_binomial_2_lpmf<false>(y_data[(t - 1)][(j - 1)],
                  rvalue(E_deathsByAge,
                    cons_list(index_uni(t),
                      cons_list(index_uni(j), nil_index_list())),
                    "E_deathsByAge"),
                  (rvalue(E_deathsByAge,
                     cons_list(index_uni(t),
                       cons_list(index_uni(j), nil_index_list())),
                     "E_deathsByAge") / phiD)),
                "assigning variable log_like_age");
            } 
          }}
        current_statement__ = 70;
        assign(log_lik, cons_list(index_uni(t), nil_index_list()),
          sum(
            rvalue(log_like_age,
              cons_list(index_uni(t),
                cons_list(index_omni(), nil_index_list())), "log_like_age")),
          "assigning variable log_lik");}
      current_statement__ = 73;
      deviance = (-2 * sum(log_lik));
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        vars__.emplace_back(E_cases[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        vars__.emplace_back(E_deaths[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          vars__.emplace_back(
            rvalue(Susceptibles,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "Susceptibles"));}}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
          vars__.emplace_back(
            rvalue(log_like_age,
              cons_list(index_uni(sym2__),
                cons_list(index_uni(sym1__), nil_index_list())),
              "log_like_age"));}}
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        vars__.emplace_back(log_lik[(sym1__ - 1)]);}
      vars__.emplace_back(deviance);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, stan::require_std_vector_t<VecVar>* = nullptr, stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr>
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      double x0;
      x0 = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 1;
      x0 = context__.vals_r("x0")[(1 - 1)];
      std::vector<double> x_init;
      x_init = std::vector<double>(A, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 2;
      assign(x_init, nil_index_list(), context__.vals_r("x_init"),
        "assigning variable x_init");
      std::vector<double> x_noise;
      x_noise = std::vector<double>(x_noise_1dim__, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 3;
      assign(x_noise, nil_index_list(), context__.vals_r("x_noise"),
        "assigning variable x_noise");
      double pi;
      pi = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      pi = context__.vals_r("pi")[(1 - 1)];
      double pi_free__;
      pi_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      pi_free__ = stan::math::lub_free(pi, 0, 1);
      std::vector<double> volatilities;
      volatilities = std::vector<double>(A, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      assign(volatilities, nil_index_list(),
        context__.vals_r("volatilities"), "assigning variable volatilities");
      std::vector<double> volatilities_free__;
      volatilities_free__ = std::vector<double>(A, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 5;
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        current_statement__ = 5;
        assign(volatilities_free__,
          cons_list(index_uni(sym1__), nil_index_list()),
          stan::math::lb_free(volatilities[(sym1__ - 1)], 0),
          "assigning variable volatilities_free__");}
      double phiD;
      phiD = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      phiD = context__.vals_r("phiD")[(1 - 1)];
      double phiD_free__;
      phiD_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 6;
      phiD_free__ = stan::math::lb_free(phiD, 0);
      Eigen::Matrix<double, -1, 1> L_raw;
      L_raw = Eigen::Matrix<double, -1, 1>(L_raw_length);
      stan::math::fill(L_raw, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> L_raw_flat__;
        current_statement__ = 7;
        assign(L_raw_flat__, nil_index_list(), context__.vals_r("L_raw"),
          "assigning variable L_raw_flat__");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= L_raw_length; ++sym1__) {
          current_statement__ = 7;
          assign(L_raw, cons_list(index_uni(sym1__), nil_index_list()),
            L_raw_flat__[(pos__ - 1)], "assigning variable L_raw");
          current_statement__ = 7;
          pos__ = (pos__ + 1);}
      }
      vars__.emplace_back(x0);
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        vars__.emplace_back(x_init[(sym1__ - 1)]);}
      for (int sym1__ = 1; sym1__ <= x_noise_1dim__; ++sym1__) {
        vars__.emplace_back(x_noise[(sym1__ - 1)]);}
      vars__.emplace_back(pi_free__);
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        vars__.emplace_back(volatilities_free__[(sym1__ - 1)]);}
      vars__.emplace_back(phiD_free__);
      for (int sym1__ = 1; sym1__ <= L_raw_length; ++sym1__) {
        vars__.emplace_back(L_raw[(sym1__ - 1)]);}
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__.clear();
    names__.emplace_back("x0");
    names__.emplace_back("x_init");
    names__.emplace_back("x_noise");
    names__.emplace_back("pi");
    names__.emplace_back("volatilities");
    names__.emplace_back("phiD");
    names__.emplace_back("L_raw");
    names__.emplace_back("x_trajectory");
    names__.emplace_back("beta0");
    names__.emplace_back("beta_trajectory");
    names__.emplace_back("beta_N");
    names__.emplace_back("theta");
    names__.emplace_back("state_solutions");
    names__.emplace_back("comp_C");
    names__.emplace_back("E_casesByAge");
    names__.emplace_back("E_deathsByAge");
    names__.emplace_back("cm_sym");
    names__.emplace_back("cm_sample");
    names__.emplace_back("L_raw_mat");
    names__.emplace_back("L");
    names__.emplace_back("x_noise_mat");
    names__.emplace_back("E_cases");
    names__.emplace_back("E_deaths");
    names__.emplace_back("Susceptibles");
    names__.emplace_back("log_like_age");
    names__.emplace_back("log_lik");
    names__.emplace_back("deviance");
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    dimss__.clear();
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(x_noise_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(L_raw_length)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_changes),
                                             static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_obs),
                                             static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(beta_N_1dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(theta_1dim__)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_obs),
                                             static_cast<size_t>(state_solutions_2dim__)
                                             });
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_obs),
                                             static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_obs),
                                             static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_obs),
                                             static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(A),
                                             static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(A),
                                             static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(A),
                                             static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(A),
                                             static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{
                                             static_cast<size_t>(x_noise_mat_1dim__)
                                             , static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_obs)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_obs)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_obs),
                                             static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_obs),
                                             static_cast<size_t>(A)});
    
    dimss__.emplace_back(std::vector<size_t>{static_cast<size_t>(n_obs)});
    
    dimss__.emplace_back(std::vector<size_t>{});
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "x0");
    for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x_init" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= x_noise_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x_noise" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "pi");
    for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "volatilities" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "phiD");
    for (int sym1__ = 1; sym1__ <= L_raw_length; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "L_raw" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_changes; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x_trajectory" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      param_names__.emplace_back(std::string() + "beta0");
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "beta_trajectory" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= beta_N_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "beta_N" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= theta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= state_solutions_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "state_solutions" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "comp_C" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "E_casesByAge" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "E_deathsByAge" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "cm_sym" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "cm_sample" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "L_raw_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "L" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= x_noise_mat_1dim__; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x_noise_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "E_cases" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "E_deaths" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "Susceptibles" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "log_like_age" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik" + '.' + std::to_string(sym1__));
        }}
      param_names__.emplace_back(std::string() + "deviance");
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    param_names__.emplace_back(std::string() + "x0");
    for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x_init" + '.' + std::to_string(sym1__));
      }}
    for (int sym1__ = 1; sym1__ <= x_noise_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "x_noise" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "pi");
    for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "volatilities" + '.' + std::to_string(sym1__));
      }}
    param_names__.emplace_back(std::string() + "phiD");
    for (int sym1__ = 1; sym1__ <= L_raw_length; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "L_raw" + '.' + std::to_string(sym1__));
      }}
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_changes; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x_trajectory" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      param_names__.emplace_back(std::string() + "beta0");
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "beta_trajectory" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= beta_N_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "beta_N" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= theta_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "theta" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= state_solutions_2dim__; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "state_solutions" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "comp_C" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "E_casesByAge" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "E_deathsByAge" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "cm_sym" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "cm_sample" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "L_raw_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= A; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "L" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= x_noise_mat_1dim__; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "x_noise_mat" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
    }
    
    if (emit_generated_quantities__) {
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "E_cases" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "E_deaths" + '.' + std::to_string(sym1__));
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "Susceptibles" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= A; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= n_obs; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "log_like_age" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            }}
        }}
      for (int sym1__ = 1; sym1__ <= n_obs; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "log_lik" + '.' + std::to_string(sym1__));
        }}
      param_names__.emplace_back(std::string() + "deviance");
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_init\",\"type\":{\"name\":\"array\",\"length\":" << A << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_noise\",\"type\":{\"name\":\"array\",\"length\":" << x_noise_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"pi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"volatilities\",\"type\":{\"name\":\"array\",\"length\":" << A << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"phiD\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"L_raw\",\"type\":{\"name\":\"vector\",\"length\":" << L_raw_length << "},\"block\":\"parameters\"},{\"name\":\"x_trajectory\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_changes << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"beta_trajectory\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"beta_N\",\"type\":{\"name\":\"array\",\"length\":" << beta_N_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << theta_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"state_solutions\",\"type\":{\"name\":\"array\",\"length\":" << n_obs << ",\"element_type\":{\"name\":\"array\",\"length\":" << state_solutions_2dim__ << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"comp_C\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"E_casesByAge\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"E_deathsByAge\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"cm_sym\",\"type\":{\"name\":\"matrix\",\"rows\":" << A << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"cm_sample\",\"type\":{\"name\":\"matrix\",\"rows\":" << A << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"L_raw_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" << A << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"L\",\"type\":{\"name\":\"matrix\",\"rows\":" << A << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"x_noise_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" << x_noise_mat_1dim__ << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"E_cases\",\"type\":{\"name\":\"vector\",\"length\":" << n_obs << "},\"block\":\"generated_quantities\"},{\"name\":\"E_deaths\",\"type\":{\"name\":\"vector\",\"length\":" << n_obs << "},\"block\":\"generated_quantities\"},{\"name\":\"Susceptibles\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"generated_quantities\"},{\"name\":\"log_like_age\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"generated_quantities\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"vector\",\"length\":" << n_obs << "},\"block\":\"generated_quantities\"},{\"name\":\"deviance\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    stringstream s__;
    s__ << "[{\"name\":\"x0\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"x_init\",\"type\":{\"name\":\"array\",\"length\":" << A << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"x_noise\",\"type\":{\"name\":\"array\",\"length\":" << x_noise_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"pi\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"volatilities\",\"type\":{\"name\":\"array\",\"length\":" << A << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"parameters\"},{\"name\":\"phiD\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"L_raw\",\"type\":{\"name\":\"vector\",\"length\":" << L_raw_length << "},\"block\":\"parameters\"},{\"name\":\"x_trajectory\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_changes << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"beta0\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"beta_trajectory\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"beta_N\",\"type\":{\"name\":\"array\",\"length\":" << beta_N_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"theta\",\"type\":{\"name\":\"array\",\"length\":" << theta_1dim__ << ",\"element_type\":{\"name\":\"real\"}},\"block\":\"transformed_parameters\"},{\"name\":\"state_solutions\",\"type\":{\"name\":\"array\",\"length\":" << n_obs << ",\"element_type\":{\"name\":\"array\",\"length\":" << state_solutions_2dim__ << ",\"element_type\":{\"name\":\"real\"}}},\"block\":\"transformed_parameters\"},{\"name\":\"comp_C\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"E_casesByAge\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"E_deathsByAge\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"cm_sym\",\"type\":{\"name\":\"matrix\",\"rows\":" << A << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"cm_sample\",\"type\":{\"name\":\"matrix\",\"rows\":" << A << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"L_raw_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" << A << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"L\",\"type\":{\"name\":\"matrix\",\"rows\":" << A << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"x_noise_mat\",\"type\":{\"name\":\"matrix\",\"rows\":" << x_noise_mat_1dim__ << ",\"cols\":" << A << "},\"block\":\"transformed_parameters\"},{\"name\":\"E_cases\",\"type\":{\"name\":\"vector\",\"length\":" << n_obs << "},\"block\":\"generated_quantities\"},{\"name\":\"E_deaths\",\"type\":{\"name\":\"vector\",\"length\":" << n_obs << "},\"block\":\"generated_quantities\"},{\"name\":\"Susceptibles\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"generated_quantities\"},{\"name\":\"log_like_age\",\"type\":{\"name\":\"matrix\",\"rows\":" << n_obs << ",\"cols\":" << A << "},\"block\":\"generated_quantities\"},{\"name\":\"log_lik\",\"type\":{\"name\":\"vector\",\"length\":" << n_obs << "},\"block\":\"generated_quantities\"},{\"name\":\"deviance\",\"type\":{\"name\":\"real\"},\"block\":\"generated_quantities\"}]";
    return s__.str();
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i) {
        vars.coeffRef(i) = vars_vec[i];
      }
    }
    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars, emit_transformed_parameters, emit_generated_quantities, pstream);
    }
    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }
  
    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i) {
        params_r.coeffRef(i) = params_r_vec[i];
      }
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }        
};
}
using stan_model = model_igbm_namespace::model_igbm;
#ifndef USING_R
// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
stan::math::profile_map& get_stan_profile_data() {
  return model_igbm_namespace::profiles__;
}
#endif
#endif
